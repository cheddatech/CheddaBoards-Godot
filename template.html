<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CheddaClick</title>

  <!-- Godot engine bootstrap -->
  <script src="index.js"></script>
  
  <!-- CheddaBoards SDK (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/cheddaboards_v1@latest/cheddaboards.min.js"></script>

  <!-- Google Sign-In (optional - remove if not using) -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>

  <!-- Apple Sign-In (optional - remove if not using) -->
  <script type="text/javascript" src="https://appleid.cdn-apple.com/appleauth/static/jsapi/appleid/1/en_US/appleid.auth.js"></script>

  <style>
    html, body { 
      margin: 0; 
      height: 100%; 
      overflow: hidden; 
      background: #000; 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; 
    }
    
    #preload {
      position: absolute; 
      inset: 0;
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      justify-content: center;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
      color: #FFD700; 
      z-index: 9999; 
      transition: opacity 0.5s ease-out;
    }
    
    #preload.fade { 
      opacity: 0; 
      pointer-events: none; 
    }
    
    .loading-text {
      font-size: 1.2rem;
      margin-bottom: 1rem;
      animation: pulse 1.5s ease-in-out infinite;
    }
    
    #spin {
      width: 40px; 
      height: 40px;
      border: 3px solid rgba(255, 215, 0, 0.2); 
      border-top: 3px solid #FFD700;
      border-radius: 50%; 
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin { 
      to { transform: rotate(360deg); } 
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    canvas { 
      width: 100vw; 
      height: 100vh; 
      object-fit: contain; 
    }
  </style>
</head>
<body>
  <!-- Preloader -->
  <div id="preload">
    <div class="loading-text">Loading...</div>
    <div id="spin"></div>
  </div>

  <!-- Main canvas for Godot -->
  <canvas id="canvas">Your browser doesn't support HTML5 canvas.</canvas>

  <script type="module">
    // ============================================================
    // CheddaBoards Godot 4 Template v1.5.2
    // WITH DEVICE ID / ANONYMOUS PLAY SUPPORT
    // WITH PLAY SESSION TIME VALIDATION SUPPORT (HTTP API for all users)
    // https://github.com/cheddatech/CheddaBoards-Godot
    // https://cheddaboards.com
    // ============================================================

    // ============================================================
    // CONFIGURATION - CUSTOMIZE THESE VALUES
    // ============================================================
    const CONFIG = {
      // ─────────────────────────────────────────────────────────
      // REQUIRED: Your Game ID from https://cheddaboards.com
      // ─────────────────────────────────────────────────────────
      GAME_ID: 'test-game',  // CHANGE THIS
      
      // ─────────────────────────────────────────────────────────
      // CheddaBoards canister (same for all games)
      // ─────────────────────────────────────────────────────────
      CANISTER_ID: 'fdvph-sqaaa-aaaap-qqc4a-cai',
      
      // ─────────────────────────────────────────────────────────
      // OPTIONAL: Google Sign-In
      // Get Client ID from: https://console.cloud.google.com/
      // Leave empty '' to disable Google login
      // ─────────────────────────────────────────────────────────
      GOOGLE_CLIENT_ID: '',  // Your Google OAuth Client ID
      
      // ─────────────────────────────────────────────────────────
      // OPTIONAL: Apple Sign-In
      // Get Service ID from: https://developer.apple.com/
      // Leave empty '' to disable Apple login
      // ─────────────────────────────────────────────────────────
      APPLE_SERVICE_ID: '',      // Your Apple Service ID
      APPLE_REDIRECT_URI: '',    // https://yourdomain.com/auth/apple
      
      // ─────────────────────────────────────────────────────────
      // ANONYMOUS PLAY: Allow scores without login
      // ─────────────────────────────────────────────────────────
      ALLOW_ANONYMOUS_PLAY: true,  // Set to false to require login
      
      // ─────────────────────────────────────────────────────────
      // API KEY: Required for anonymous play session validation
      // Get from: https://cheddaboards.com/dashboard
      // ─────────────────────────────────────────────────────────
      API_KEY: 'cb_test-game_350355445',  // Your API key (cb_xxxxx)
      API_BASE_URL: 'https://api.cheddaboards.com',
    };

    // ============================================================
    // INTERNAL STATE (don't modify)
    // ============================================================
    let chedda = null;
    let godotReady = false;
    let responseQueue = [];
    let currentProfile = null;
    let isAuthenticated = false;
    let authType = '';
    
    // Device ID for anonymous play
    let deviceId = null;
    const DEVICE_ID_KEY = `cheddaboards_device_${CONFIG.GAME_ID}`;
    
    // Anonymous nickname (set by Godot before login)
    let pendingNickname = null;
    
    // Rate limiting
    let loginAttempts = 0;
    let lastLoginAttempt = 0;
    const MAX_LOGIN_ATTEMPTS = 5;
    const LOCKOUT_DURATION = 60000; // 1 minute

    // Caching
    let cachedProfileData = null;
    let lastProfileFetch = 0;
    const PROFILE_CACHE_DURATION = 30000; // 30 seconds
    const PROFILE_STORAGE_KEY = `cheddaboards_profile_${CONFIG.GAME_ID}`;
    
    // Timeouts
    const LOGIN_TIMEOUT = 60000; // 60 seconds
    
    // Submission guards
    let isRefreshingProfile = false;
    let isSubmittingScore = false;
    
    // Play session for time validation anti-cheat
    let playSessionToken = null;

    // ============================================================
    // DEVICE ID MANAGEMENT
    // ============================================================
    
    function generateDeviceId() {
      const array = new Uint8Array(16);
      crypto.getRandomValues(array);
      return 'dev_' + Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    }
    
    function getOrCreateDeviceId() {
      if (deviceId) return deviceId;
      
      try {
        const stored = localStorage.getItem(DEVICE_ID_KEY);
        if (stored) {
          deviceId = stored;
          console.log('[Device] Loaded device ID:', deviceId.substring(0, 12) + '...');
          return deviceId;
        }
        
        deviceId = generateDeviceId();
        localStorage.setItem(DEVICE_ID_KEY, deviceId);
        console.log('[Device] Generated new device ID:', deviceId.substring(0, 12) + '...');
        return deviceId;
      } catch (e) {
        deviceId = generateDeviceId();
        console.warn('[Device] localStorage unavailable, using temporary ID');
        return deviceId;
      }
    }

    // ============================================================
    // HELPER FUNCTIONS
    // ============================================================
    
    function saveProfileToLocalStorage(profile) {
      try {
        localStorage.setItem(PROFILE_STORAGE_KEY, JSON.stringify({
          profile: profile,
          timestamp: Date.now()
        }));
      } catch (e) {
        console.warn('[Storage] Failed to save profile:', e);
      }
    }

    function loadProfileFromLocalStorage() {
      try {
        const data = localStorage.getItem(PROFILE_STORAGE_KEY);
        if (data) {
          const parsed = JSON.parse(data);
          if (Date.now() - parsed.timestamp < 3600000) {
            console.log('[Storage] Instant profile from localStorage');
            return parsed.profile;
          }
        }
      } catch (e) {
        console.warn('[Storage] Failed to load profile:', e);
      }
      return null;
    }
    
    function sanitizeProfileData(profile, forceRefresh = false) {
      if (!profile) return null;
      
      const now = Date.now();
      if (!forceRefresh && cachedProfileData && (now - lastProfileFetch) < PROFILE_CACHE_DURATION) {
        console.log('[Helper] Using cached profile data');
        return cachedProfileData;
      }
      
      console.log('[Helper] Sanitizing fresh profile data:', profile);
      
      const sanitized = {
        nickname: String(profile.nickname || profile.username || 'Player'),
        score: parseInt(profile.score || profile.highScore || 0) || 0,
        streak: parseInt(profile.streak || profile.bestStreak || 0) || 0,
        playCount: parseInt(profile.playCount || profile.plays || 0) || 0,
        achievements: Array.isArray(profile.achievements) ? profile.achievements : [],
        authType: profile.authType || authType || 'unknown',
        deviceId: profile.deviceId || deviceId || null
      };
      
      cachedProfileData = sanitized;
      lastProfileFetch = now;
      
      console.log('[Helper] Sanitized profile:', sanitized);
      return sanitized;
    }
    
    function checkRateLimit() {
      const now = Date.now();
      
      if (now - lastLoginAttempt > LOCKOUT_DURATION) {
        loginAttempts = 0;
      }
      
      if (loginAttempts >= MAX_LOGIN_ATTEMPTS) {
        const timeLeft = Math.ceil((LOCKOUT_DURATION - (now - lastLoginAttempt)) / 1000);
        throw new Error(`Too many login attempts. Please wait ${timeLeft} seconds.`);
      }
      
      loginAttempts++;
      lastLoginAttempt = now;
      console.log(`[RateLimit] Login attempt ${loginAttempts}/${MAX_LOGIN_ATTEMPTS}`);
    }

    function handleLoginSuccess(type, profile) {
      console.log('[Helper] Login success:', type, profile);
      isAuthenticated = true;
      authType = type;
      
      cachedProfileData = null;
      lastProfileFetch = 0;
      currentProfile = sanitizeProfileData(profile, true);
      
      let actionName = 'login';
      switch(type) {
        case 'cheddaId':
        case 'internetIdentity':
          actionName = 'loginInternetIdentity';
          break;
        case 'google':
          actionName = 'loginGoogle';
          break;
        case 'apple':
          actionName = 'loginApple';
          break;
        case 'anonymous':
        case 'device':
          actionName = 'loginAnonymous';
          break;
      }
      
      responseQueue.push({
        action: actionName,
        success: true,
        profile: currentProfile,
        authType: type
      });
      
      saveProfileToLocalStorage(currentProfile);
      console.log('[Helper] Login response queued');
    }
    
    function handleLoginError(error) {
      console.error('[Helper] Login error:', error);
      responseQueue.push({
        action: 'login',
        success: false,
        error: error.message || 'Login failed'
      });
    }
    
    // ============================================================
    // GODOT BRIDGE FUNCTIONS
    // ============================================================
    
    window.chedda_get_response = function() {
      if (responseQueue.length > 0) {
        const response = responseQueue.shift();
        console.log('[Bridge] Sending response to Godot:', response);
        return JSON.stringify(response);
      }
      return null;
    };
    
    window.chedda_is_auth = function() {
      if (chedda && chedda.isAuthenticated()) {
        return true;
      }
      if (CONFIG.ALLOW_ANONYMOUS_PLAY && deviceId) {
        return true;
      }
      return false;
    };
    
    window.chedda_has_account = function() {
      if (!chedda) return false;
      if (!chedda.isAuthenticated()) return false;
      const at = chedda.getAuthType ? chedda.getAuthType() : authType;
      return at === 'google' || at === 'apple' || at === 'cheddaId';
    };
    
    window.chedda_is_anonymous = function() {
      if (!chedda) return true;
      if (!chedda.isAuthenticated()) return true;
      const at = chedda.getAuthType ? chedda.getAuthType() : authType;
      return !at || at === 'device' || at === 'anonymous';
    };
    
    window.chedda_get_device_id = function() {
      return getOrCreateDeviceId();
    };
    
    window.chedda_get_profile = function() {
      if (currentProfile) {
        return JSON.stringify(currentProfile);
      }
      return null;
    };

    /**
     * Set player ID (device ID) - called from Godot before anonymous login
     */
    window.chedda_set_player_id = function(playerId) {
      if (playerId) {
        deviceId = playerId;
        console.log('[Bridge] Player ID set to:', playerId.substring(0, 12) + '...');
      }
    };

    /**
     * Anonymous login - NOW ACCEPTS NICKNAME PARAMETER
     */
    window.chedda_login_anonymous = async function(nickname) {
      try {
        console.log('[Bridge] Anonymous login requested with nickname:', nickname);
        
        const devId = getOrCreateDeviceId();
        
        // Use provided nickname, or pending nickname, or generate from device ID
        const finalNickname = nickname || pendingNickname || ('Player_' + devId.substring(4, 10));
        pendingNickname = null; // Clear pending
        
        console.log('[Login] Final nickname:', finalNickname);
        
        if (chedda && chedda.login && chedda.login.anonymous) {
          console.log('[Login] Using SDK anonymous login...');
          const profile = await chedda.login.anonymous(devId, finalNickname);
          handleLoginSuccess('anonymous', profile);
        } else {
          console.log('[Login] Creating local anonymous profile...');
          isAuthenticated = true;
          authType = 'device';
          
          // Check for existing profile
          let anonProfile = loadProfileFromLocalStorage();
          
          // If no existing profile OR nickname is different, update it
          if (!anonProfile || anonProfile.deviceId !== devId) {
            anonProfile = {
              nickname: finalNickname,
              score: 0,
              streak: 0,
              playCount: 0,
              achievements: [],
              authType: 'device',
              deviceId: devId
            };
          } else {
            // Update nickname if provided
            if (nickname) {
              anonProfile.nickname = finalNickname;
            }
          }
          
          anonProfile.deviceId = devId;
          
          currentProfile = sanitizeProfileData(anonProfile, true);
          saveProfileToLocalStorage(currentProfile);
          
          responseQueue.push({
            action: 'loginAnonymous',
            success: true,
            profile: currentProfile,
            authType: 'device',
            deviceId: devId
          });
          
          console.log('[Login] Anonymous login complete:', currentProfile.nickname);
        }
      } catch (error) {
        console.error('[Login] Anonymous login error:', error);
        handleLoginError(error);
      }
    };

    window.chedda_login_ii = async function(nickname) {
      let timeoutId = null;
      
      try {
        checkRateLimit();
        console.log('[Bridge] Internet Identity login requested');

        timeoutId = setTimeout(() => {
          handleLoginError(new Error('Login timeout - please try again'));
        }, LOGIN_TIMEOUT);

        if (!chedda.isAuthenticated()) {
          console.log('[Login] Attempting to restore session...');
          await chedda.restoreSession?.().catch(() => {});
        }

        const cached = loadProfileFromLocalStorage();
        if (cached && chedda.isAuthenticated()) {
          console.log('[Login] Using cached profile');
          clearTimeout(timeoutId);
          handleLoginSuccess('cheddaId', cached);
          
          chedda.getProfile().then(profile => {
            if (profile) {
              const freshProfile = sanitizeProfileData(profile);
              currentProfile = freshProfile;
              saveProfileToLocalStorage(freshProfile);
              responseQueue.push({
                action: 'getProfile',
                success: true,
                profile: freshProfile
              });
            }
          }).catch(console.error);
          return;
        }

        console.log('[Login] Initiating Internet Identity login...');
        const profile = await chedda.login.chedda(nickname);
        console.log('[Login] Login complete:', profile);
        
        clearTimeout(timeoutId);
        handleLoginSuccess('cheddaId', profile);

      } catch (error) {
        if (timeoutId) clearTimeout(timeoutId);
        console.error('[Login] Login failed:', error);
        handleLoginError(error);
      }
    };

    window.chedda_login_google = function() {
      try {
        checkRateLimit();
        console.log('[Bridge] Google login requested');
        
        if (!window.google?.accounts) {
          handleLoginError({ message: 'Google Sign-In not available. Check GOOGLE_CLIENT_ID in config.' });
          return;
        }

        const timeoutId = setTimeout(() => {
          console.log('[Google] Login timeout');
          handleLoginError({ message: 'Google login timeout - popup may have been blocked or closed' });
        }, LOGIN_TIMEOUT);

        window._googleLoginTimeout = timeoutId;
        
        google.accounts.id.prompt((notification) => {
          clearTimeout(window._googleLoginTimeout);
          
          if (notification.isNotDisplayed()) {
            console.log('[Google] Popup not displayed:', notification.getNotDisplayedReason());
            handleLoginError({ 
              message: 'Google Sign-In popup blocked. Please allow popups and try again.' 
            });
          } else if (notification.isSkippedMoment()) {
            console.log('[Google] User closed the popup');
            handleLoginError({ message: 'Google Sign-In cancelled' });
          }
        });
        
      } catch (error) {
        if (window._googleLoginTimeout) {
          clearTimeout(window._googleLoginTimeout);
        }
        handleLoginError(error);
      }
    };

    window.chedda_login_apple = async function() {
      let timeoutId = null;
      
      try {
        checkRateLimit();
        console.log('[Bridge] Apple login requested');
        
        if (!window.AppleID?.auth) {
          handleLoginError({ message: 'Apple Sign-In not available. Check APPLE_SERVICE_ID in config.' });
          return;
        }

        timeoutId = setTimeout(() => {
          handleLoginError(new Error('Apple login timeout - popup may have been blocked or closed'));
        }, LOGIN_TIMEOUT);
        
        window._appleLoginTimeout = timeoutId;

        await AppleID.auth.signIn();

      } catch (error) {
        if (timeoutId) clearTimeout(timeoutId);
        console.error('[Apple] Login error:', error);
        
        if (error.error !== 'popup_closed_by_user') {
          handleLoginError({ 
            message: error.message || 'Apple Sign-In failed. Please try again.' 
          });
        } else {
          console.log('[Apple] User cancelled login');
          handleLoginError({ message: 'Apple Sign-In cancelled' });
        }
      }
    };

    window.chedda_logout = async function() {
      try {
        if (chedda && chedda.isAuthenticated()) {
          await chedda.logout();
        }
        
        isAuthenticated = false;
        authType = '';
        currentProfile = null;
        cachedProfileData = null;
        pendingNickname = null;
        
        localStorage.removeItem(PROFILE_STORAGE_KEY);
        
        responseQueue.push({
          action: 'logout',
          success: true
        });
      } catch (error) {
        responseQueue.push({
          action: 'logout',
          success: false,
          error: error.message
        });
      }
    };

    window.chedda_refresh_profile = async function() {
      if (isRefreshingProfile) {
        console.log('[Bridge] Profile refresh already in progress');
        return;
      }
      
      try {
        if (authType === 'device' || authType === 'anonymous') {
          if (currentProfile) {
            responseQueue.push({
              action: 'getProfile',
              success: true,
              profile: currentProfile
            });
          }
          return;
        }
        
        if (!chedda || !chedda.isAuthenticated()) {
          responseQueue.push({
            action: 'getProfile',
            success: false,
            error: 'Not authenticated'
          });
          return;
        }
        
        isRefreshingProfile = true;
        cachedProfileData = null;
        lastProfileFetch = 0;
        console.log('[Bridge] Profile refresh requested');
        
        const profile = await chedda.getProfile(true);
        console.log('[Bridge] Profile received from backend:', profile);
        
        if (profile) {
          currentProfile = sanitizeProfileData(profile, true);
          saveProfileToLocalStorage(currentProfile);
          responseQueue.push({
            action: 'getProfile',
            success: true,
            profile: currentProfile
          });
        } else {
          responseQueue.push({
            action: 'getProfile',
            success: false,
            error: 'No profile data'
          });
        }
      } catch (error) {
        responseQueue.push({
          action: 'getProfile',
          success: false,
          error: error.message
        });
      } finally {
        isRefreshingProfile = false;
      }
    };

    /**
     * Submit score - FIXED: Submit score FIRST, then achievements
     */
    window.chedda_submit_score = async function(score, streak, achievements = []) {
      if (isSubmittingScore) {
        console.log('[Bridge] Score submission already in progress');
        return;
      }
      
      try {
        isSubmittingScore = true;
        console.log('[Bridge] Score submission:', score, streak);
        console.log('[Bridge] Achievements to unlock:', achievements);
        console.log('[Bridge] Auth type:', authType, 'isAuthenticated:', chedda?.isAuthenticated());
        
        let result = null;
        
        if (chedda && chedda.isAuthenticated()) {
          console.log('[Bridge] Submitting via authenticated session...');
          
          // Submit score FIRST to create/update game profile
          result = await chedda.submitScore(score, streak);
          console.log('[Bridge] Score result:', result);
          
          // THEN unlock achievements (profile now exists)
          if (achievements && achievements.length > 0) {
            console.log('[Bridge] Unlocking %d achievements...', achievements.length);
            for (const achId of achievements) {
              try {
                const achResult = await chedda.unlockAchievement(achId);
                console.log('[Bridge] Achievement unlocked:', achId, achResult);
              } catch (e) {
                console.error('[Bridge] Achievement unlock failed:', achId, e);
              }
            }
          }
        }
        else if (CONFIG.ALLOW_ANONYMOUS_PLAY) {
          console.log('[Bridge] Submitting via device ID...');
          
          if (!deviceId) {
            getOrCreateDeviceId();
          }
          
          if (chedda && chedda.submitScoreAnonymous) {
            result = await chedda.submitScoreAnonymous(deviceId, score, streak);
          } 
          else if (chedda && chedda.submitScore) {
            try {
              result = await chedda.submitScore(score, streak, { deviceId: deviceId });
            } catch (e) {
              console.log('[Bridge] SDK submit failed, using local storage');
            }
          }
          
          if (!result || result.err) {
            console.log('[Bridge] Using local score storage for anonymous user');
            
            if (currentProfile) {
              if (score > (currentProfile.score || 0)) {
                currentProfile.score = score;
              }
              if (streak > (currentProfile.streak || 0)) {
                currentProfile.streak = streak;
              }
              currentProfile.playCount = (currentProfile.playCount || 0) + 1;
              
              if (achievements && achievements.length > 0) {
                if (!currentProfile.achievements) {
                  currentProfile.achievements = [];
                }
                for (const achId of achievements) {
                  if (!currentProfile.achievements.includes(achId)) {
                    currentProfile.achievements.push(achId);
                  }
                }
              }
              
              saveProfileToLocalStorage(currentProfile);
            }
            
            result = { ok: true, local: true };
          }
        } else {
          responseQueue.push({
            action: 'submitScore',
            success: false,
            error: 'Not authenticated - login required'
          });
          return;
        }
        
        console.log('[Bridge] Score submission result:', result);
        
        const success = result && (
          result.ok !== undefined || 
          result.success === true || 
          result.local === true ||
          (typeof result === 'object' && !result.err && !result.error)
        );
        
        if (success) {
          console.log('[Bridge] Score submitted successfully');
          
          responseQueue.push({
            action: 'submitScore',
            success: true,
            score: score,
            streak: streak,
            profile: currentProfile,
            local: result.local || false
          });
          
          if (chedda && chedda.isAuthenticated()) {
            cachedProfileData = null;
            lastProfileFetch = 0;
            chedda.getProfile().then(profile => {
              if (profile) {
                currentProfile = sanitizeProfileData(profile, true);
                saveProfileToLocalStorage(currentProfile);
              }
            }).catch(console.warn);
          }
        } else {
          const errorMsg = result?.err || result?.error || 'Score submission failed';
          console.error('[Bridge] Score submission failed:', errorMsg);
          responseQueue.push({
            action: 'submitScore',
            success: false,
            error: errorMsg
          });
        }
      } catch (error) {
        console.error('[Bridge] Score submission error:', error);
        responseQueue.push({
          action: 'submitScore',
          success: false,
          error: error.message
        });
      } finally {
        isSubmittingScore = false;
      }
    };

    /**
     * Start a play session for time validation anti-cheat
     * Call this when the game STARTS (before submitting any scores)
     * Returns the session token to be used with score submission
     * 
     * v1.5.2: Now uses HTTP API for ALL users (simpler, works everywhere)
     */
    window.chedda_start_play_session = async function(gameId) {
      try {
        console.log('[Bridge] Starting play session for game:', gameId || CONFIG.GAME_ID);
        
        const targetGameId = gameId || CONFIG.GAME_ID;
        const playerId = deviceId || getOrCreateDeviceId();
        
        // Use HTTP API for ALL users (authenticated and anonymous)
        if (CONFIG.API_KEY) {
          try {
            console.log('[Bridge] Starting play session via HTTP API...');
            const response = await fetch(`${CONFIG.API_BASE_URL}/play-sessions/start`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-API-Key': CONFIG.API_KEY
              },
              body: JSON.stringify({
                gameId: targetGameId,
                playerId: playerId
              })
            });
            
            if (response.ok) {
              const data = await response.json();
              if (data.ok) {
                playSessionToken = data.ok;
                console.log('[Bridge] Play session started (HTTP):', playSessionToken.substring(0, 25) + '...');
                return JSON.stringify({ ok: playSessionToken });
              } else if (data.data && data.data.token) {
                // Alternative response format
                playSessionToken = data.data.token;
                console.log('[Bridge] Play session started (HTTP):', playSessionToken.substring(0, 25) + '...');
                return JSON.stringify({ ok: playSessionToken });
              } else {
                console.warn('[Bridge] HTTP API returned error:', data.error || data.err);
              }
            } else {
              const errorText = await response.text();
              console.warn('[Bridge] HTTP API failed:', response.status, errorText);
            }
          } catch (e) {
            console.warn('[Bridge] HTTP API error:', e.message);
          }
        } else {
          console.warn('[Bridge] No API_KEY configured - play sessions disabled');
        }
        
        // Fallback: generate local token (time validation will NOT be enforced)
        playSessionToken = 'local_' + Date.now() + '_' + Math.random().toString(36).substring(2, 8);
        console.log('[Bridge] Play session fallback (no server validation):', playSessionToken);
        return JSON.stringify({ ok: playSessionToken, fallback: true });
        
      } catch (error) {
        console.error('[Bridge] Play session error:', error);
        playSessionToken = 'error_' + Date.now();
        return JSON.stringify({ ok: playSessionToken, fallback: true });
      }
    };

    /**
     * Get current play session token
     */
    window.chedda_get_play_session_token = function() {
      return playSessionToken;
    };

    /**
     * Clear play session (after score submitted)
     */
    window.chedda_clear_play_session = function() {
      playSessionToken = null;
      console.log('[Bridge] Play session cleared');
    };

    /**
     * Submit score WITH play session token for time validation
     */
    window.chedda_submit_score_with_session = async function(score, streak, sessionToken) {
      // Store the session token for this submission
      const tokenToUse = sessionToken || playSessionToken;
      console.log('[Bridge] Submitting score with session:', tokenToUse ? tokenToUse.substring(0, 20) + '...' : 'none');
      
      // Use the regular submit function - the SDK should handle the token
      // We pass it through the chedda object if supported
      if (chedda && chedda.submitScoreWithSession) {
        try {
          const result = await chedda.submitScoreWithSession(score, streak, tokenToUse);
          responseQueue.push({
            action: 'submitScore',
            success: !result.err,
            score: score,
            streak: streak,
            error: result.err
          });
          return;
        } catch (e) {
          console.warn('[Bridge] submitScoreWithSession not available, using standard submit');
        }
      }
      
      // Fallback: use standard submit (token may be ignored by older SDK)
      // The Godot HTTP API will handle the token directly
      await window.chedda_submit_score(score, streak);
    };

    window.chedda_get_leaderboard = async function(sortBy = 'score', limit = 100) {
      try {
        console.log('[Bridge] Leaderboard requested:', sortBy, limit);
        
        if (!chedda) {
          responseQueue.push({
            action: 'getLeaderboard',
            success: false,
            error: 'SDK not initialized'
          });
          return;
        }
        
        const leaderboard = await chedda.getLeaderboard(sortBy, limit);
        console.log('[Bridge] Leaderboard received:', leaderboard?.length || 0, 'entries');
        
        responseQueue.push({
          action: 'getLeaderboard',
          success: true,
          entries: leaderboard || []
        });
      } catch (error) {
        console.error('[Bridge] Leaderboard error:', error);
        responseQueue.push({
          action: 'getLeaderboard',
          success: false,
          error: error.message
        });
      }
    };

    window.chedda_get_player_rank = async function(sortBy = 'score') {
      try {
        if (!chedda || !chedda.isAuthenticated()) {
          responseQueue.push({
            action: 'getPlayerRank',
            success: false,
            error: 'Not authenticated'
          });
          return;
        }
        
        console.log('[Bridge] Player rank requested:', sortBy);
        const rank = await chedda.getPlayerRank(sortBy);
        
        responseQueue.push({
          action: 'getPlayerRank',
          success: true,
          rank: rank.rank || 0,
          score: rank.score || 0,
          streak: rank.streak || 0,
          totalPlayers: rank.totalPlayers || 0
        });
      } catch (error) {
        console.error('[Bridge] Rank error:', error);
        responseQueue.push({
          action: 'getPlayerRank',
          success: false,
          error: error.message
        });
      }
    };

    window.chedda_unlock_achievement = async function(achievementId, name, description) {
      try {
        if (authType === 'device' || authType === 'anonymous') {
          console.log('[Bridge] Storing achievement locally:', achievementId);
          if (currentProfile) {
            if (!currentProfile.achievements) currentProfile.achievements = [];
            if (!currentProfile.achievements.find(a => a.id === achievementId)) {
              currentProfile.achievements.push({ id: achievementId, name, description });
              saveProfileToLocalStorage(currentProfile);
            }
          }
          responseQueue.push({
            action: 'unlockAchievement',
            success: true,
            achievementId: achievementId,
            local: true
          });
          return;
        }
        
        if (!chedda || !chedda.isAuthenticated()) {
          responseQueue.push({
            action: 'unlockAchievement',
            success: false,
            error: 'Not authenticated'
          });
          return;
        }
        
        console.log('[Bridge] Unlocking achievement:', achievementId);
        await chedda.unlockAchievement(achievementId, name, description);
        
        responseQueue.push({
          action: 'unlockAchievement',
          success: true,
          achievementId: achievementId
        });
      } catch (error) {
        responseQueue.push({
          action: 'unlockAchievement',
          success: false,
          error: error.message
        });
      }
    };

    /**
     * Change nickname directly (called from Godot)
     * FIXED: Now properly updates anonymous profiles
     */
    window.chedda_change_nickname = async function(newNickname) {
      try {
        if (!newNickname || !newNickname.trim()) {
          responseQueue.push({
            action: 'changeNickname',
            success: false,
            error: 'Nickname required'
          });
          return;
        }
        
        const nickname = newNickname.trim();
        console.log('[Bridge] Changing nickname to:', nickname);
        
        // Store as pending nickname for next anonymous login
        pendingNickname = nickname;
        
        // For anonymous users - update immediately
        if (authType === 'device' || authType === 'anonymous') {
          if (currentProfile) {
            currentProfile.nickname = nickname;
            saveProfileToLocalStorage(currentProfile);
            console.log('[Bridge] Anonymous nickname updated to:', nickname);
          }
          responseQueue.push({
            action: 'changeNickname',
            success: true,
            nickname: nickname
          });
          return;
        }
        
        // For authenticated users
        if (!chedda || !chedda.isAuthenticated()) {
          // Not authenticated yet - store for later
          console.log('[Bridge] Storing pending nickname:', nickname);
          responseQueue.push({
            action: 'changeNickname',
            success: true,
            nickname: nickname,
            pending: true
          });
          return;
        }
        
        await chedda.changeNickname(nickname);
        
        if (currentProfile) {
          currentProfile.nickname = nickname;
          saveProfileToLocalStorage(currentProfile);
        }
        
        responseQueue.push({
          action: 'changeNickname',
          success: true,
          nickname: nickname
        });
        
        console.log('[Bridge] Nickname changed successfully');
      } catch (error) {
        console.error('[Bridge] Nickname change error:', error);
        responseQueue.push({
          action: 'changeNickname',
          success: false,
          error: error.message
        });
      }
    };

    /**
     * Change nickname with prompt
     */
    window.chedda_change_nickname_prompt = async function() {
      try {
        const currentNick = currentProfile?.nickname || 'Player';
        const newNickname = prompt('Enter your nickname:', currentNick);
        
        if (newNickname && newNickname.trim()) {
          await window.chedda_change_nickname(newNickname.trim());
        } else {
          responseQueue.push({
            action: 'changeNickname',
            success: false,
            cancelled: true
          });
        }
      } catch (error) {
        responseQueue.push({
          action: 'changeNickname',
          success: false,
          error: error.message
        });
      }
    };
    
    // ============================================================
    // INITIALIZATION
    // ============================================================
    window.addEventListener('load', async () => {
      console.log('[Init] CheddaBoards Template v1.5.2 (HTTP API play sessions)');
      console.log('[Init] Game ID:', CONFIG.GAME_ID);
      console.log('[Init] Anonymous Play:', CONFIG.ALLOW_ANONYMOUS_PLAY ? 'Enabled' : 'Disabled');

      getOrCreateDeviceId();

      if (CONFIG.GAME_ID === 'YOUR-GAME-ID') {
        console.error('[Init] ERROR: You must set your GAME_ID in the CONFIG section!');
        document.querySelector('.loading-text').textContent = 'Error: Game not configured';
        return;
      }

      try {
        let attempts = 0;
        while (!window.CheddaBoards && attempts < 50) {
          await new Promise(resolve => setTimeout(resolve, 100));
          attempts++;
        }

        if (!window.CheddaBoards) {
          throw new Error('CheddaBoards SDK not loaded. Check your internet connection.');
        }

        console.log('[Init] Initializing CheddaBoards...');
        chedda = await window.CheddaBoards.init(CONFIG.CANISTER_ID, {
          gameId: CONFIG.GAME_ID,
          host: 'https://icp-api.io'
        });

        window.chedda = chedda;
        console.log('[Init] CheddaBoards initialized');

        if (chedda.isAuthenticated()) {
          console.log('[Init] User is authenticated');
          isAuthenticated = true;
          authType = chedda.getAuthType ? chedda.getAuthType() : 'unknown';

          const cachedProfile = loadProfileFromLocalStorage();
          if (cachedProfile) {
            currentProfile = cachedProfile;
            responseQueue.push({
              action: 'init',
              success: true,
              authenticated: true,
              authType,
              profile: currentProfile
            });
          } else {
            responseQueue.push({
              action: 'init',
              success: true,
              authenticated: true,
              authType,
              profile: null
            });
          }

          chedda.getProfile().then(profile => {
            if (profile) {
              currentProfile = sanitizeProfileData(profile);
              saveProfileToLocalStorage(currentProfile);
              responseQueue.push({
                action: 'getProfile',
                success: true,
                profile: currentProfile
              });
            }
          }).catch(console.error);
        } else if (CONFIG.ALLOW_ANONYMOUS_PLAY) {
          console.log('[Init] Setting up anonymous play with device ID');
          const cachedProfile = loadProfileFromLocalStorage();
          if (cachedProfile && cachedProfile.deviceId === deviceId) {
            currentProfile = cachedProfile;
            authType = 'device';
            console.log('[Init] Restored anonymous profile:', currentProfile.nickname);
          }
          
          responseQueue.push({
            action: 'init',
            success: true,
            authenticated: false,
            anonymousReady: true,
            deviceId: deviceId,
            cachedNickname: currentProfile?.nickname || null
          });
        } else {
          responseQueue.push({
            action: 'init',
            success: true,
            authenticated: false
          });
        }

        // Initialize Google Sign-In
        if (CONFIG.GOOGLE_CLIENT_ID && window.google?.accounts) {
          google.accounts.id.initialize({
            client_id: CONFIG.GOOGLE_CLIENT_ID,
            callback: async (response) => {
              if (window._googleLoginTimeout) {
                clearTimeout(window._googleLoginTimeout);
              }
              
              try {
                const profile = await chedda.login.google(response.credential);
                handleLoginSuccess('google', profile);
              } catch (error) {
                handleLoginError(error);
              }
            },
            auto_select: false,
            cancel_on_tap_outside: true
          });
          
          console.log('[Init] Google Sign-In initialized');
        }

        // Initialize Apple Sign-In
        if (CONFIG.APPLE_SERVICE_ID && CONFIG.APPLE_REDIRECT_URI && window.AppleID?.auth) {
          AppleID.auth.init({
            clientId: CONFIG.APPLE_SERVICE_ID,
            scope: 'name email',
            redirectURI: CONFIG.APPLE_REDIRECT_URI,
            state: 'signin',
            usePopup: true
          });

          document.addEventListener('AppleIDSignInOnSuccess', async (event) => {
            if (window._appleLoginTimeout) {
              clearTimeout(window._appleLoginTimeout);
            }

            try {
              const auth = event.detail?.authorization;
              if (!auth?.id_token) throw new Error("Missing id_token");
              const profile = await chedda.login.apple(auth);
              handleLoginSuccess('apple', profile);
            } catch (error) {
              handleLoginError(error);
            }
          });

          document.addEventListener('AppleIDSignInOnFailure', (event) => {
            if (window._appleLoginTimeout) {
              clearTimeout(window._appleLoginTimeout);
            }
            handleLoginError({ message: 'Apple Sign-In failed or cancelled' });
          });

          console.log('[Init] Apple Sign-In initialized');
        }

        // Initialize Godot engine
        const engine = new Engine({
          canvasResizePolicy: 2,
          executable: 'index',
          fileSizes: { 'index.pck': 0, 'index.wasm': 0 },
          focusCanvas: true,
          canvas: document.getElementById('canvas')
        });

        await engine.startGame();
        window.godot = engine;
        godotReady = true;
        console.log('[Init] Godot engine started');

        setTimeout(() => {
          const preload = document.getElementById('preload');
          preload?.classList.add('fade');
          setTimeout(() => preload?.remove(), 500);
        }, 500);

        console.log('[Init] All systems ready!');
        
      } catch (error) {
        console.error('[Init] Initialization failed:', error);
        document.querySelector('.loading-text').textContent = 'Error: ' + error.message;
      }
    });

    // ============================================================
    // DEBUG HELPER
    // ============================================================
    window.debugChedda = () => {
      console.log('═══════════════════════════════════════');
      console.log('CheddaBoards Debug Info v1.5.0');
      console.log('═══════════════════════════════════════');
      console.log('Game ID:', CONFIG.GAME_ID);
      console.log('Anonymous Play:', CONFIG.ALLOW_ANONYMOUS_PLAY);
      console.log('───────────────────────────────────────');
      console.log('SDK Instance:', chedda ? 'Loaded' : 'Not loaded');
      console.log('SDK Authenticated:', chedda?.isAuthenticated() || false);
      console.log('Local Authenticated:', isAuthenticated);
      console.log('Auth Type:', authType || 'None');
      console.log('Device ID:', deviceId ? deviceId.substring(0, 12) + '...' : 'Not set');
      console.log('Pending Nickname:', pendingNickname || 'None');
      console.log('───────────────────────────────────────');
      console.log('Play Session:', playSessionToken ? playSessionToken.substring(0, 20) + '...' : 'None');
      console.log('───────────────────────────────────────');
      console.log('Profile:', currentProfile);
      console.log('Response Queue:', responseQueue.length, 'items');
      console.log('Godot Ready:', godotReady);
      console.log('───────────────────────────────────────');
      console.log('Google:', CONFIG.GOOGLE_CLIENT_ID ? 'Configured' : 'Disabled');
      console.log('Apple:', CONFIG.APPLE_SERVICE_ID ? 'Configured' : 'Disabled');
      console.log('═══════════════════════════════════════');
      return { chedda, currentProfile, responseQueue, deviceId, pendingNickname, playSessionToken, CONFIG };
    };
  </script>
</body>
</html>

