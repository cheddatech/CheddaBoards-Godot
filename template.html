<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CheddaMatch</title>

  <!-- Godot engine bootstrap -->
  <script src="index.js"></script>
  
  <script>
    (function() {
      const _realPrompt = window.prompt.bind(window);
      window.prompt = function(msg, defaultVal) {
        console.log('[PromptGuard] Suppressed SDK prompt:', msg);
        return null;
      };
      window._realPrompt = _realPrompt;
    })();
  </script>

  <!-- CheddaBoards SDK (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/cheddaboards_v1@latest/cheddaboards.min.js"></script>

  <!-- Google Sign-In (optional - remove if not using) -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>

  <!-- Apple Sign-In (optional - remove if not using) -->
  <script type="text/javascript" src="https://appleid.cdn-apple.com/appleauth/static/jsapi/appleid/1/en_US/appleid.auth.js"></script>

  <style>
    html, body { 
      margin: 0; 
      height: 100%; 
      overflow: hidden; 
      background: #000; 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; 
    }
    
    #preload {
      position: absolute; 
      inset: 0;
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      justify-content: center;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
      color: #FFD700; 
      z-index: 9999; 
      transition: opacity 0.5s ease-out;
    }
    
    #preload.fade { 
      opacity: 0; 
      pointer-events: none; 
    }
    
    .loading-text {
      font-size: 1.2rem;
      margin-bottom: 1rem;
      animation: pulse 1.5s ease-in-out infinite;
    }
    
    #spin {
      width: 40px; 
      height: 40px;
      border: 3px solid rgba(255, 215, 0, 0.2); 
      border-top: 3px solid #FFD700;
      border-radius: 50%; 
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin { 
      to { transform: rotate(360deg); } 
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    canvas { 
      width: 100vw; 
      height: 100vh; 
      object-fit: contain; 
    }
  </style>
</head>
<body>
  <!-- Preloader -->
  <div id="preload">
    <div class="loading-text">Loading...</div>
    <div id="spin"></div>
  </div>

  <!-- Main canvas for Godot -->
  <canvas id="canvas">Your browser doesn't support HTML5 canvas.</canvas>

  <script type="module">
    // ============================================================
    // CheddaBoards Godot 4 Template v1.5.15
    // WITH DEVICE ID / ANONYMOUS PLAY SUPPORT
    // WITH PLAY SESSION TIME VALIDATION SUPPORT (HTTP API for all users)
    // https://github.com/cheddatech/CheddaBoards-Godot
    // https://cheddaboards.com
    // ============================================================

    // ============================================================
    // CONFIGURATION - CUSTOMIZE THESE VALUES
    // ============================================================
    const CONFIG = {
      // ─────────────────────────────────────────────────────────
      // REQUIRED: Your Game ID from https://cheddaboards.com
      // ─────────────────────────────────────────────────────────
      GAME_ID: 'test-game',  // CHANGE THIS
      
      // ─────────────────────────────────────────────────────────
      // CheddaBoards canister (same for all games)
      // ─────────────────────────────────────────────────────────
      CANISTER_ID: 'fdvph-sqaaa-aaaap-qqc4a-cai',
      
      // ─────────────────────────────────────────────────────────
      // OPTIONAL: Google Sign-In
      // Get Client ID from: https://console.cloud.google.com/
      // Leave empty '' to disable Google login
      // ─────────────────────────────────────────────────────────
      GOOGLE_CLIENT_ID: '',  // Your Google OAuth Client ID
      
      // ─────────────────────────────────────────────────────────
      // OPTIONAL: Apple Sign-In
      // Get Service ID from: https://developer.apple.com/
      // Leave empty '' to disable Apple login
      // ─────────────────────────────────────────────────────────
      APPLE_SERVICE_ID: '',      // Your Apple Service ID
      APPLE_REDIRECT_URI: '',    // https://yourdomain.com/auth/apple
      
      // ─────────────────────────────────────────────────────────
      // ANONYMOUS PLAY: Allow scores without login
      // ─────────────────────────────────────────────────────────
      ALLOW_ANONYMOUS_PLAY: true,  // Set to false to require login
      
      // ─────────────────────────────────────────────────────────
      // API KEY: Required for anonymous play session validation
      // Get from: https://cheddaboards.com/dashboard
      // ─────────────────────────────────────────────────────────
      API_KEY: 'cb_test-game_350355445',  // Your API key (cb_xxxxx)
      API_BASE_URL: 'https://api.cheddaboards.com',
    };

    // ============================================================
    // HTTP API WRAPPER (replaces SDK for all operations)
    // ============================================================
    const CheddaAPI = {
      sessionId: null,
      gameId: CONFIG.GAME_ID,
      baseUrl: CONFIG.API_BASE_URL,
      _authenticated: false,
      _authType: null,
      _profile: null,
      
      // Helper for HTTP requests
      async _fetch(endpoint, options = {}) {
        const headers = {
          'Content-Type': 'application/json',
          'X-Game-Id': this.gameId,
          ...(this.sessionId && { 'X-Session-Token': this.sessionId }),
          ...options.headers
        };
        
        const response = await fetch(`${this.baseUrl}${endpoint}`, {
          ...options,
          headers
        });
        
        return response.json();
      },
      
      // ─────────────────────────────────────────────────────────
      // AUTH METHODS
      // ─────────────────────────────────────────────────────────
      login: {
        async google(idToken, nickname) {
          const data = await CheddaAPI._fetch('/auth/google', {
            method: 'POST',
            body: JSON.stringify({ idToken, nickname })
          });
          
          if (data.success && data.sessionId) {
            CheddaAPI.sessionId = data.sessionId;
            CheddaAPI._authenticated = true;
            CheddaAPI._authType = 'google';
            CheddaAPI._profile = {
              nickname: data.nickname,
              score: data.gameProfile?.score || 0,
              streak: data.gameProfile?.streak || 0,
              achievements: data.gameProfile?.achievements || [],
              playCount: data.gameProfile?.playCount || 0,
              isNewUser: data.isNewUser
            };
            return CheddaAPI._profile;
          }
          
          throw new Error(data.error || 'Google login failed');
        },
        
        async apple(auth, nickname) {
          const data = await CheddaAPI._fetch('/auth/apple', {
            method: 'POST',
            body: JSON.stringify({
              identityToken: auth.identityToken || auth.authorization?.id_token,
              authorizationCode: auth.authorizationCode || auth.authorization?.code,
              user: auth.user,
              nickname
            })
          });
          
          if (data.success && data.sessionId) {
            CheddaAPI.sessionId = data.sessionId;
            CheddaAPI._authenticated = true;
            CheddaAPI._authType = 'apple';
            CheddaAPI._profile = {
              nickname: data.nickname,
              score: data.gameProfile?.score || 0,
              streak: data.gameProfile?.streak || 0,
              achievements: data.gameProfile?.achievements || [],
              playCount: data.gameProfile?.playCount || 0,
              isNewUser: data.isNewUser
            };
            return CheddaAPI._profile;
          }
          
          throw new Error(data.error || 'Apple login failed');
        },
        
        async anonymous(deviceId, nickname) {
          const data = await CheddaAPI._fetch('/auth/anonymous', {
            method: 'POST',
            body: JSON.stringify({ deviceId, nickname })
          });
          
          if (data.success && data.sessionId) {
            CheddaAPI.sessionId = data.sessionId;
            CheddaAPI._authenticated = true;
            CheddaAPI._authType = 'anonymous';
            CheddaAPI._profile = {
              nickname: data.nickname,
              score: data.gameProfile?.score || 0,
              streak: data.gameProfile?.streak || 0,
              achievements: data.gameProfile?.achievements || [],
              playCount: data.gameProfile?.playCount || 0
            };
            return CheddaAPI._profile;
          }
          
          throw new Error(data.error || 'Anonymous login failed');
        }
      },
      
      // ─────────────────────────────────────────────────────────
      // PROFILE & SCORES
      // ─────────────────────────────────────────────────────────
      async refreshProfile() {
        const data = await this._fetch('/auth/profile');
        
        if (data.success) {
          this._profile = {
            nickname: data.nickname,
            score: data.gameProfile?.score || 0,
            streak: data.gameProfile?.streak || 0,
            achievements: data.gameProfile?.achievements || [],
            playCount: data.gameProfile?.playCount || 0,
            lastPlayed: data.gameProfile?.lastPlayed
          };
          return this._profile;
        }
        
        return null;
      },
      
      async submitScore(score, streak) {
        const data = await this._fetch('/scores', {
          method: 'POST',
          body: JSON.stringify({ score, streak })
        });
        
        return data.success 
          ? { success: true, message: data.message }
          : { success: false, error: data.error };
      },
      
      async unlockAchievement(achievementId) {
        const data = await this._fetch('/achievements', {
          method: 'POST',
          body: JSON.stringify({ achievementId })
        });
        
        return data.success
          ? { success: true, message: data.message }
          : { success: false, error: data.error };
      },
      
      async changeNickname(nickname) {
        const data = await this._fetch('/profile/nickname', {
          method: 'PUT',
          body: JSON.stringify({ nickname })
        });
        
        if (data.success) {
          if (this._profile) this._profile.nickname = nickname;
          return { success: true };
        }
        
        return { success: false, error: data.error };
      },
      
      // ─────────────────────────────────────────────────────────
      // LEADERBOARDS
      // ─────────────────────────────────────────────────────────
      async getScoreboard(scoreboardName, limit = 100) {
        const data = await this._fetch(`/games/${this.gameId}/scoreboards/${scoreboardName}?limit=${limit}`);
        return data.success ? data.entries : [];
      },
      
      async getScoreboardRank(scoreboardName) {
        const data = await this._fetch(`/games/${this.gameId}/scoreboards/${scoreboardName}/rank`);
        return data.success ? { rank: data.rank, total: data.total } : { rank: 0, total: 0 };
      },
      
      // ─────────────────────────────────────────────────────────
      // SESSION MANAGEMENT
      // ─────────────────────────────────────────────────────────
      isAuthenticated() {
        return this._authenticated && !!this.sessionId;
      },
      
      getAuthType() {
        return this._authType;
      },
      
      getProfile() {
        return this._profile;
      },
      
      async logout() {
        if (this.sessionId) {
          await this._fetch('/auth/logout', { method: 'POST' }).catch(() => {});
        }
        this.sessionId = null;
        this._authenticated = false;
        this._authType = null;
        this._profile = null;
        return { success: true };
      },
      
      // Instance accessor for compatibility
      get instance() {
        return {
          sessionId: this.sessionId,
          gameId: this.gameId
        };
      }
    };

    // ============================================================
    // INTERNAL STATE (don't modify)
    // ============================================================
    let chedda = null;
    let godotReady = false;
    let responseQueue = [];
    let currentProfile = null;
    let isAuthenticated = false;
    let authType = '';
    
    // Device ID for anonymous play
    let deviceId = null;
    const DEVICE_ID_KEY = `cheddaboards_device_${CONFIG.GAME_ID}`;
    
    // Anonymous nickname (set by Godot before login)
    let pendingNickname = null;
    let renamedNickname = null;
    
    // Rate limiting
    let loginAttempts = 0;
    let lastLoginAttempt = 0;
    const MAX_LOGIN_ATTEMPTS = 5;
    const LOCKOUT_DURATION = 60000; // 1 minute

    // Caching
    let cachedProfileData = null;
    let lastProfileFetch = 0;
    const PROFILE_CACHE_DURATION = 30000; // 30 seconds
    const PROFILE_STORAGE_KEY = `cheddaboards_profile_${CONFIG.GAME_ID}`;
    
    // Timeouts
    const LOGIN_TIMEOUT = 60000; // 60 seconds
    
    // Submission guards
    let isRefreshingProfile = false;
    let isSubmittingScore = false;
    
    // Play session for time validation anti-cheat
    let playSessionToken = null;
    
    // SDK session token (for authenticated API calls after Google/Apple login)
    let sdkSessionToken = null;

    // ============================================================
    // DEVICE ID MANAGEMENT
    // ============================================================
    
    function generateDeviceId() {
      const array = new Uint8Array(16);
      crypto.getRandomValues(array);
      return 'dev_' + Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    }
    
    function getOrCreateDeviceId() {
      if (deviceId) return deviceId;
      
      try {
        const stored = localStorage.getItem(DEVICE_ID_KEY);
        if (stored) {
          deviceId = stored;
          console.log('[Device] Loaded device ID:', deviceId.substring(0, 12) + '...');
          return deviceId;
        }
        
        deviceId = generateDeviceId();
        localStorage.setItem(DEVICE_ID_KEY, deviceId);
        console.log('[Device] Generated new device ID:', deviceId.substring(0, 12) + '...');
        return deviceId;
      } catch (e) {
        deviceId = generateDeviceId();
        console.warn('[Device] localStorage unavailable, using temporary ID');
        return deviceId;
      }
    }

    // ============================================================
    // HELPER FUNCTIONS
    // ============================================================
    
    function saveProfileToLocalStorage(profile) {
      try {
        localStorage.setItem(PROFILE_STORAGE_KEY, JSON.stringify({
          profile: profile,
          timestamp: Date.now()
        }));
      } catch (e) {
        console.warn('[Storage] Failed to save profile:', e);
      }
    }

    function loadProfileFromLocalStorage() {
      try {
        const data = localStorage.getItem(PROFILE_STORAGE_KEY);
        if (data) {
          const parsed = JSON.parse(data);
          if (Date.now() - parsed.timestamp < 3600000) {
            console.log('[Storage] Instant profile from localStorage');
            return parsed.profile;
          }
        }
      } catch (e) {
        console.warn('[Storage] Failed to load profile:', e);
      }
      return null;
    }
    
    function sanitizeProfileData(profile, forceRefresh = false) {
      if (!profile) return null;
      
      const now = Date.now();
      if (!forceRefresh && cachedProfileData && (now - lastProfileFetch) < PROFILE_CACHE_DURATION) {
        console.log('[Helper] Using cached profile data');
        return cachedProfileData;
      }
      
      console.log('[Helper] Sanitizing fresh profile data:', profile);
      
      const sanitized = {
        nickname: String(profile.nickname || profile.username || 'Player'),
        score: parseInt(profile.score || profile.highScore || 0) || 0,
        streak: parseInt(profile.streak || profile.bestStreak || 0) || 0,
        playCount: parseInt(profile.playCount || profile.plays || 0) || 0,
        achievements: Array.isArray(profile.achievements) ? profile.achievements : [],
        authType: profile.authType || authType || 'unknown',
        deviceId: profile.deviceId || deviceId || null
      };
      
      cachedProfileData = sanitized;
      lastProfileFetch = now;
      
      console.log('[Helper] Sanitized profile:', sanitized);
      return sanitized;
    }
    
    function checkRateLimit() {
      const now = Date.now();
      
      if (now - lastLoginAttempt > LOCKOUT_DURATION) {
        loginAttempts = 0;
      }
      
      if (loginAttempts >= MAX_LOGIN_ATTEMPTS) {
        const timeLeft = Math.ceil((LOCKOUT_DURATION - (now - lastLoginAttempt)) / 1000);
        throw new Error(`Too many login attempts. Please wait ${timeLeft} seconds.`);
      }
      
      loginAttempts++;
      lastLoginAttempt = now;
      console.log(`[RateLimit] Login attempt ${loginAttempts}/${MAX_LOGIN_ATTEMPTS}`);
    }

    function handleLoginSuccess(type, profile) {
      console.log('[Helper] Login success:', type, profile);
      isAuthenticated = true;
      authType = type;
      
      // Capture SDK session token for authenticated API calls
      sdkSessionToken = null;
      if (chedda) {
        // Check chedda.instance first (this is where the real SDK state lives)
        if (chedda.instance) {
          if (chedda.instance.sessionId) {
            sdkSessionToken = chedda.instance.sessionId;
            console.log('[Helper] Session token via .instance.sessionId:', sdkSessionToken.substring(0, 20) + '...');
          } else if (chedda.instance.userId) {
            sdkSessionToken = chedda.instance.userId;
            console.log('[Helper] Session token via .instance.userId:', sdkSessionToken.substring(0, 20) + '...');
          }
        }
        // Fallback to direct properties (older SDK versions)
        if (!sdkSessionToken && typeof chedda.getSessionId === 'function') {
          sdkSessionToken = chedda.getSessionId();
          if (sdkSessionToken) console.log('[Helper] Session token via getSessionId():', sdkSessionToken.substring(0, 20) + '...');
        }
        if (!sdkSessionToken && chedda.sessionId) {
          sdkSessionToken = chedda.sessionId;
          console.log('[Helper] Session token via .sessionId:', sdkSessionToken.substring(0, 20) + '...');
        }
        if (!sdkSessionToken) {
          console.warn('[Helper] Could not capture session token');
        }
      }
      
      cachedProfileData = null;
      lastProfileFetch = 0;
      currentProfile = sanitizeProfileData(profile, true);
      
      let actionName = 'login';
      switch(type) {
        case 'cheddaId':
        case 'internetIdentity':
          actionName = 'loginInternetIdentity';
          break;
        case 'google':
          actionName = 'loginGoogle';
          break;
        case 'apple':
          actionName = 'loginApple';
          break;
        case 'anonymous':
        case 'device':
          actionName = 'loginAnonymous';
          break;
      }
      
      responseQueue.push({
        action: actionName,
        success: true,
        profile: currentProfile,
        authType: type,
        sessionToken: sdkSessionToken || null
      });
      
      saveProfileToLocalStorage(currentProfile);
      console.log('[Helper] Login response queued');
    }
    
    function handleLoginError(error) {
      console.error('[Helper] Login error:', error);
      responseQueue.push({
        action: 'login',
        success: false,
        error: error.message || 'Login failed'
      });
    }
    
    // ============================================================
    // GODOT BRIDGE FUNCTIONS
    // ============================================================
    
    window.chedda_get_response = function() {
      if (responseQueue.length > 0) {
        const response = responseQueue.shift();
        console.log('[Bridge] Sending response to Godot:', response);
        return JSON.stringify(response);
      }
      return null;
    };
    
    window.chedda_is_auth = function() {
      if (chedda && chedda.isAuthenticated()) {
        return true;
      }
      if (CONFIG.ALLOW_ANONYMOUS_PLAY && deviceId) {
        return true;
      }
      return false;
    };
    
    window.chedda_has_account = function() {
      if (!chedda) return false;
      if (!chedda.isAuthenticated()) return false;
      const at = chedda.getAuthType ? chedda.getAuthType() : authType;
      return at === 'google' || at === 'apple' || at === 'cheddaId';
    };
    
    window.chedda_is_anonymous = function() {
      if (!chedda) return true;
      if (!chedda.isAuthenticated()) return true;
      const at = chedda.getAuthType ? chedda.getAuthType() : authType;
      return !at || at === 'device' || at === 'anonymous';
    };
    
    window.chedda_get_device_id = function() {
      return getOrCreateDeviceId();
    };
    
    window.chedda_get_profile = function() {
      if (currentProfile) {
        return JSON.stringify(currentProfile);
      }
      return null;
    };

    /**
     * Get the SDK's session token for authenticated API calls
     * This is needed for rank lookups and profile fetches after Google/Apple login
     */
    window.chedda_get_session_token = function() {
      // First try our cached token
      if (sdkSessionToken) {
        console.log('[Bridge] Session token (cached):', sdkSessionToken.substring(0, 20) + '...');
        return sdkSessionToken;
      }
      
      // Try to get from SDK - check chedda.instance first (wrapper pattern)
      if (chedda) {
        if (chedda.instance?.sessionId) {
          sdkSessionToken = chedda.instance.sessionId;
          console.log('[Bridge] Session token (.instance.sessionId):', sdkSessionToken.substring(0, 20) + '...');
          return sdkSessionToken;
        }
        if (chedda.instance?.userId) {
          sdkSessionToken = chedda.instance.userId;
          console.log('[Bridge] Session token (.instance.userId):', sdkSessionToken.substring(0, 20) + '...');
          return sdkSessionToken;
        }
        // Fallback to direct properties
        if (typeof chedda.getSessionId === 'function') {
          const token = chedda.getSessionId();
          if (token) {
            sdkSessionToken = token;
            console.log('[Bridge] Session token (getSessionId):', token.substring(0, 20) + '...');
            return token;
          }
        }
        if (chedda.sessionId) {
          sdkSessionToken = chedda.sessionId;
          console.log('[Bridge] Session token (.sessionId):', chedda.sessionId.substring(0, 20) + '...');
          return chedda.sessionId;
        }
      }
      
      console.log('[Bridge] No session token available');
      return null;
    };

    /**
     * Get user ID appropriate for API calls
     * Returns session ID for Google/Apple users, device ID for anonymous
     */
    window.chedda_get_user_id = function() {
      // For authenticated users, use session ID
      if (chedda && chedda.isAuthenticated()) {
        const sessionId = window.chedda_get_session_token();
        if (sessionId) {
          console.log('[Bridge] User ID (session):', sessionId.substring(0, 12) + '...');
          return sessionId;
        }
      }
      
      // Fallback to device ID
      const devId = deviceId || getOrCreateDeviceId();
      console.log('[Bridge] User ID (device):', devId.substring(0, 12) + '...');
      return devId;
    };

    /**
     * Check if we have a valid session token for authenticated API calls
     */
    window.chedda_has_session_token = function() {
      return !!(sdkSessionToken || (chedda && chedda.getSessionId && chedda.getSessionId()));
    };

    /**
     * Set player ID (device ID) - called from Godot before anonymous login
     */
    window.chedda_set_player_id = function(playerId) {
      if (playerId) {
        deviceId = playerId;
        console.log('[Bridge] Player ID set to:', playerId.substring(0, 12) + '...');
      }
    };

    /**
     * Anonymous login - NOW ACCEPTS NICKNAME PARAMETER
     */
    window.chedda_login_anonymous = async function(nickname) {
      try {
        console.log('[Bridge] Anonymous login requested with nickname:', nickname);
        
        const devId = getOrCreateDeviceId();
        
        // Use provided nickname, or pending nickname, or generate from device ID
        const finalNickname = nickname || pendingNickname || ('Player_' + devId.substring(4, 10));
        pendingNickname = null; // Clear pending
        
        console.log('[Login] Final nickname:', finalNickname);
        
        if (chedda && chedda.login && chedda.login.anonymous) {
          console.log('[Login] Using SDK anonymous login...');
          const profile = await chedda.login.anonymous(devId, finalNickname);
          handleLoginSuccess('anonymous', profile);
        } else {
          console.log('[Login] Creating local anonymous profile...');
          isAuthenticated = true;
          authType = 'device';
          
          // Check for existing profile
          let anonProfile = loadProfileFromLocalStorage();
          
          // If no existing profile OR nickname is different, update it
          if (!anonProfile || anonProfile.deviceId !== devId) {
            anonProfile = {
              nickname: finalNickname,
              score: 0,
              streak: 0,
              playCount: 0,
              achievements: [],
              authType: 'device',
              deviceId: devId
            };
          } else {
            // Update nickname if provided
            if (nickname) {
              anonProfile.nickname = finalNickname;
            }
          }
          
          anonProfile.deviceId = devId;
          
          currentProfile = sanitizeProfileData(anonProfile, true);
          saveProfileToLocalStorage(currentProfile);
          
          responseQueue.push({
            action: 'loginAnonymous',
            success: true,
            profile: currentProfile,
            authType: 'device',
            deviceId: devId
          });
          
          console.log('[Login] Anonymous login complete:', currentProfile.nickname);
        }
      } catch (error) {
        console.error('[Login] Anonymous login error:', error);
        handleLoginError(error);
      }
    };

    window.chedda_login_ii = async function(nickname) {
      let timeoutId = null;
      
      try {
        checkRateLimit();
        console.log('[Bridge] Internet Identity login requested');

        timeoutId = setTimeout(() => {
          handleLoginError(new Error('Login timeout - please try again'));
        }, LOGIN_TIMEOUT);

        if (!chedda.isAuthenticated()) {
          console.log('[Login] Attempting to restore session...');
          await chedda.restoreSession?.().catch(() => {});
        }

        const cached = loadProfileFromLocalStorage();
        if (cached && chedda.isAuthenticated()) {
          console.log('[Login] Using cached profile');
          clearTimeout(timeoutId);
          handleLoginSuccess('cheddaId', cached);
          
          chedda.getProfile().then(profile => {
            if (profile) {
              const freshProfile = sanitizeProfileData(profile);
              currentProfile = freshProfile;
              saveProfileToLocalStorage(freshProfile);
              responseQueue.push({
                action: 'getProfile',
                success: true,
                profile: freshProfile
              });
            }
          }).catch(console.error);
          return;
        }

        console.log('[Login] Initiating Internet Identity login...');
        const profile = await chedda.login.chedda(nickname);
        console.log('[Login] Login complete:', profile);
        
        clearTimeout(timeoutId);
        handleLoginSuccess('cheddaId', profile);

      } catch (error) {
        if (timeoutId) clearTimeout(timeoutId);
        console.error('[Login] Login failed:', error);
        handleLoginError(error);
      }
    };

    window.chedda_login_google = function() {
      try {
        checkRateLimit();
        console.log('[Bridge] Google login requested');
        
        if (!window.google?.accounts) {
          handleLoginError({ message: 'Google Sign-In not available. Check GOOGLE_CLIENT_ID in config.' });
          return;
        }

        const timeoutId = setTimeout(() => {
          console.log('[Google] Login timeout');
          handleLoginError({ message: 'Google login timeout - popup may have been blocked or closed' });
        }, LOGIN_TIMEOUT);

        window._googleLoginTimeout = timeoutId;
        
        google.accounts.id.prompt((notification) => {
          clearTimeout(window._googleLoginTimeout);
          
          if (notification.isNotDisplayed()) {
            console.log('[Google] Popup not displayed:', notification.getNotDisplayedReason());
            handleLoginError({ 
              message: 'Google Sign-In popup blocked. Please allow popups and try again.' 
            });
          } else if (notification.isSkippedMoment()) {
            console.log('[Google] User closed the popup');
            handleLoginError({ message: 'Google Sign-In cancelled' });
          }
        });
        
      } catch (error) {
        if (window._googleLoginTimeout) {
          clearTimeout(window._googleLoginTimeout);
        }
        handleLoginError(error);
      }
    };

    window.chedda_login_apple = async function() {
      let timeoutId = null;
      
      try {
        checkRateLimit();
        console.log('[Bridge] Apple login requested');
        
        if (!window.AppleID?.auth) {
          handleLoginError({ message: 'Apple Sign-In not available. Check APPLE_SERVICE_ID in config.' });
          return;
        }

        timeoutId = setTimeout(() => {
          handleLoginError(new Error('Apple login timeout - popup may have been blocked or closed'));
        }, LOGIN_TIMEOUT);
        
        window._appleLoginTimeout = timeoutId;

        await AppleID.auth.signIn();

      } catch (error) {
        if (timeoutId) clearTimeout(timeoutId);
        console.error('[Apple] Login error:', error);
        
        if (error.error !== 'popup_closed_by_user') {
          handleLoginError({ 
            message: error.message || 'Apple Sign-In failed. Please try again.' 
          });
        } else {
          console.log('[Apple] User cancelled login');
          handleLoginError({ message: 'Apple Sign-In cancelled' });
        }
      }
    };

    window.chedda_logout = async function() {
      try {
        if (chedda && chedda.isAuthenticated()) {
          await chedda.logout();
        }
        
        isAuthenticated = false;
        authType = '';
        currentProfile = null;
        cachedProfileData = null;
        pendingNickname = null;
        renamedNickname = null; // Clear renamed tracking on logout
        sdkSessionToken = null;  // Clear session token on logout
        
        localStorage.removeItem(PROFILE_STORAGE_KEY);
        
        responseQueue.push({
          action: 'logout',
          success: true
        });
      } catch (error) {
        responseQueue.push({
          action: 'logout',
          success: false,
          error: error.message
        });
      }
    };

    // ============================================================
    // ACCOUNT UPGRADE: Anonymous → Verified
    // ============================================================
    // These functions upgrade an anonymous device-based account to
    // a verified Google/Apple/II account, merging all scores,
    // achievements, and leaderboard positions.
    // ============================================================

    /**
     * Upgrade anonymous account to Google
     * Captures device ID, performs Google login, then migrates data
     */
    window.chedda_upgrade_to_google = function() {
      try {
        checkRateLimit();
        console.log('[Bridge] Upgrade to Google requested');

        const capturedDeviceId = deviceId || getOrCreateDeviceId();
        if (!capturedDeviceId) {
          responseQueue.push({
            action: 'upgradeToGoogle',
            success: false,
            error: 'No device ID found. Must be playing anonymously first.'
          });
          return;
        }

        console.log('[Upgrade] Captured device ID:', capturedDeviceId.substring(0, 12) + '...');

        if (!window.google?.accounts) {
          responseQueue.push({
            action: 'upgradeToGoogle',
            success: false,
            error: 'Google Sign-In not available'
          });
          return;
        }

        const timeoutId = setTimeout(() => {
          responseQueue.push({
            action: 'upgradeToGoogle',
            success: false,
            error: 'Google login timeout'
          });
        }, LOGIN_TIMEOUT);

        window._googleUpgradeTimeout = timeoutId;
        window._upgradeDeviceId = capturedDeviceId;

        // Trigger Google sign-in — the callback in google.accounts.id.initialize
        // will handle the credential. We intercept via a flag.
        window._isUpgradeFlow = 'google';

        google.accounts.id.prompt((notification) => {
          clearTimeout(window._googleUpgradeTimeout);

          if (notification.isNotDisplayed()) {
            window._isUpgradeFlow = null;
            responseQueue.push({
              action: 'upgradeToGoogle',
              success: false,
              error: 'Google popup blocked'
            });
          } else if (notification.isSkippedMoment()) {
            window._isUpgradeFlow = null;
            responseQueue.push({
              action: 'upgradeToGoogle',
              success: false,
              error: 'Google Sign-In cancelled'
            });
          }
        });

      } catch (error) {
        window._isUpgradeFlow = null;
        responseQueue.push({
          action: 'upgradeToGoogle',
          success: false,
          error: error.message
        });
      }
    };

    /**
     * Upgrade anonymous account to Apple
     */
    window.chedda_upgrade_to_apple = async function() {
      let timeoutId = null;
      try {
        checkRateLimit();
        console.log('[Bridge] Upgrade to Apple requested');

        const capturedDeviceId = deviceId || getOrCreateDeviceId();
        if (!capturedDeviceId) {
          responseQueue.push({
            action: 'upgradeToApple',
            success: false,
            error: 'No device ID found. Must be playing anonymously first.'
          });
          return;
        }

        console.log('[Upgrade] Captured device ID:', capturedDeviceId.substring(0, 12) + '...');

        if (!window.AppleID?.auth) {
          responseQueue.push({
            action: 'upgradeToApple',
            success: false,
            error: 'Apple Sign-In not available'
          });
          return;
        }

        timeoutId = setTimeout(() => {
          responseQueue.push({
            action: 'upgradeToApple',
            success: false,
            error: 'Apple login timeout'
          });
        }, LOGIN_TIMEOUT);

        window._appleUpgradeTimeout = timeoutId;
        window._upgradeDeviceId = capturedDeviceId;
        window._isUpgradeFlow = 'apple';

        await AppleID.auth.signIn();
        // The AppleIDSignInOnSuccess event handler will pick up _isUpgradeFlow

      } catch (error) {
        if (timeoutId) clearTimeout(timeoutId);
        window._isUpgradeFlow = null;
        console.error('[Upgrade] Apple upgrade error:', error);

        if (error.error !== 'popup_closed_by_user') {
          responseQueue.push({
            action: 'upgradeToApple',
            success: false,
            error: error.message || 'Apple Sign-In failed'
          });
        } else {
          responseQueue.push({
            action: 'upgradeToApple',
            success: false,
            error: 'Apple Sign-In cancelled'
          });
        }
      }
    };

    /**
     * Upgrade anonymous account to Internet Identity
     */
    window.chedda_upgrade_to_ii = async function(nickname) {
      let timeoutId = null;
      try {
        checkRateLimit();
        console.log('[Bridge] Upgrade to Internet Identity requested');

        const capturedDeviceId = deviceId || getOrCreateDeviceId();
        if (!capturedDeviceId) {
          responseQueue.push({
            action: 'upgradeToII',
            success: false,
            error: 'No device ID found. Must be playing anonymously first.'
          });
          return;
        }

        console.log('[Upgrade] Captured device ID:', capturedDeviceId.substring(0, 12) + '...');

        timeoutId = setTimeout(() => {
          responseQueue.push({
            action: 'upgradeToII',
            success: false,
            error: 'Login timeout'
          });
        }, LOGIN_TIMEOUT);

        // Use SDK upgrade method if available
        if (chedda && chedda.upgradeAnonymousToII) {
          const result = await chedda.upgradeAnonymousToII(nickname);
          clearTimeout(timeoutId);

          handleLoginSuccess('cheddaId', result.profile);

          responseQueue.push({
            action: 'upgradeToII',
            success: true,
            profile: sanitizeProfileData(result.profile, true),
            migration: result.migration
          });
        } else {
          // Fallback: login then migrate via HTTP
          const profile = await chedda.login.chedda(nickname);
          clearTimeout(timeoutId);
          handleLoginSuccess('cheddaId', profile);

          // Attempt migration via HTTP API
          const migration = await _migrateViaHttp(capturedDeviceId);

          responseQueue.push({
            action: 'upgradeToII',
            success: true,
            profile: sanitizeProfileData(profile, true),
            migration: migration
          });
        }

      } catch (error) {
        if (timeoutId) clearTimeout(timeoutId);
        console.error('[Upgrade] II upgrade error:', error);
        responseQueue.push({
          action: 'upgradeToII',
          success: false,
          error: error.message || 'Upgrade failed'
        });
      }
    };

    /**
     * Internal: Migrate anonymous account via HTTP API after social login
     */
    async function _migrateViaHttp(capturedDeviceId) {
      const sessionToken = sdkSessionToken || window.chedda_get_session_token();

      if (!sessionToken) {
        console.warn('[Upgrade] No session token for migration');
        return { success: false, error: 'No session token' };
      }

      try {
        console.log('[Upgrade] Calling /migrate-account...');
        const response = await fetch(`${CONFIG.API_BASE_URL}/migrate-account`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Session-Token': sessionToken
          },
          body: JSON.stringify({ deviceId: capturedDeviceId })
        });

        const data = await response.json();

        if (data.ok && data.data) {
          console.log('[Upgrade] Migration success:', data.data);
          return {
            success: true,
            migratedGames: data.data.migratedGames || 0,
            migratedScoreboards: data.data.migratedScoreboards || 0,
            message: data.data.message
          };
        } else {
          console.warn('[Upgrade] Migration failed:', data.error);
          return { success: false, error: data.error || 'Migration failed' };
        }
      } catch (e) {
        console.error('[Upgrade] Migration HTTP error:', e);
        return { success: false, error: e.message };
      }
    }

    window.chedda_refresh_profile = async function() {
      if (isRefreshingProfile) {
        console.log('[Bridge] Profile refresh already in progress');
        return;
      }
      
      try {
        if (authType === 'device' || authType === 'anonymous') {
          if (currentProfile) {
            responseQueue.push({
              action: 'getProfile',
              success: true,
              profile: currentProfile
            });
          }
          return;
        }
        
        if (!chedda || !chedda.isAuthenticated()) {
          responseQueue.push({
            action: 'getProfile',
            success: false,
            error: 'Not authenticated'
          });
          return;
        }
        
        isRefreshingProfile = true;
        cachedProfileData = null;
        lastProfileFetch = 0;
        console.log('[Bridge] Profile refresh requested');
        
        // Make sure we have the session token - check chedda.instance first
        if (!sdkSessionToken) {
          if (chedda.instance?.sessionId) {
            sdkSessionToken = chedda.instance.sessionId;
          } else if (chedda.instance?.userId) {
            sdkSessionToken = chedda.instance.userId;
          } else if (typeof chedda.getSessionId === 'function') {
            sdkSessionToken = chedda.getSessionId();
          } else if (chedda.sessionId) {
            sdkSessionToken = chedda.sessionId;
          }
          console.log('[Bridge] Captured session token during refresh:', sdkSessionToken ? sdkSessionToken.substring(0, 20) + '...' : 'none');
        }
        
        const profile = await chedda.getProfile(true);
        console.log('[Bridge] Profile received from backend:', profile);
        
        if (profile) {
          currentProfile = sanitizeProfileData(profile, true);
          // Preserve renamed nickname if backend returns stale data
          if (renamedNickname && currentProfile.nickname !== renamedNickname) {
            console.log("[Bridge] Preserving renamed nickname:", renamedNickname, "over backend:", currentProfile.nickname);
            currentProfile.nickname = renamedNickname;
          } else if (renamedNickname && currentProfile.nickname === renamedNickname) {
            console.log("[Bridge] Backend caught up with renamed nickname:", renamedNickname);
            renamedNickname = null;
          }
          saveProfileToLocalStorage(currentProfile);
          responseQueue.push({
            action: 'getProfile',
            success: true,
            profile: currentProfile,
            sessionToken: sdkSessionToken || null
          });
        } else if (currentProfile) {
          // User is authenticated but no game profile yet (hasn't played this game)
          // Return the cached profile from login instead of failing
          console.log('[Bridge] No game profile yet, returning login profile');
          responseQueue.push({
            action: 'getProfile',
            success: true,
            profile: currentProfile,
            sessionToken: sdkSessionToken || null,
            isNewPlayer: true
          });
        } else {
          responseQueue.push({
            action: 'getProfile',
            success: false,
            error: 'No profile data',
            sessionToken: sdkSessionToken || null
          });
        }
      } catch (error) {
        responseQueue.push({
          action: 'getProfile',
          success: false,
          error: error.message
        });
      } finally {
        isRefreshingProfile = false;
      }
    };

    window.chedda_submit_score = async function(score, streak, achievements = []) {
      if (isSubmittingScore) {
        console.log('[Bridge] Score submission already in progress');
        return;
      }
      
      try {
        isSubmittingScore = true;
        console.log('[Bridge] Score submission:', score, streak);
        console.log('[Bridge] Achievements to unlock:', achievements);
        console.log('[Bridge] Auth type:', authType, 'isAuthenticated:', chedda?.isAuthenticated());
        
        let result = null;
        
        if (chedda && chedda.isAuthenticated()) {
          console.log('[Bridge] Submitting via authenticated session (HTTP API)...');
          
          // Use HTTP API instead of SDK's broken direct canister call
          const token = sdkSessionToken || chedda?.instance?.sessionId;
          if (token) {
            try {
              const response = await fetch('https://api.cheddaboards.com/scores', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'X-Session-Token': token,
                  'X-Game-Id': CONFIG.GAME_ID
                },
                body: JSON.stringify({ score, streak })
              });
              const data = await response.json();
              console.log('[Bridge] HTTP API score result:', data);
              result = data.success ? { success: true, message: data.message } : { success: false, error: data.error };
            } catch (e) {
              console.error('[Bridge] HTTP API score failed:', e);
              result = { success: false, error: e.message };
            }
          } else {
            console.error('[Bridge] No session token for authenticated user!');
            result = { success: false, error: 'No session token' };
          }
          
          // THEN unlock achievements (profile now exists)
          if (achievements && achievements.length > 0) {
            console.log('[Bridge] Unlocking %d achievements...', achievements.length);
            for (const achId of achievements) {
              try {
                const achResult = await chedda.unlockAchievement(achId);
                console.log('[Bridge] Achievement unlocked:', achId, achResult);
              } catch (e) {
                console.error('[Bridge] Achievement unlock failed:', achId, e);
              }
            }
          }
        }
        else if (CONFIG.ALLOW_ANONYMOUS_PLAY) {
          console.log('[Bridge] Submitting via device ID...');
          
          if (!deviceId) {
            getOrCreateDeviceId();
          }
          
          if (chedda && chedda.submitScoreAnonymous) {
            result = await chedda.submitScoreAnonymous(deviceId, score, streak);
          } 
          else if (chedda && chedda.submitScore) {
            try {
              result = await chedda.submitScore(score, streak, { deviceId: deviceId });
            } catch (e) {
              console.log('[Bridge] SDK submit failed, using local storage');
            }
          }
          
          if (!result || result.err) {
            console.log('[Bridge] Using local score storage for anonymous user');
            
            if (currentProfile) {
              if (score > (currentProfile.score || 0)) {
                currentProfile.score = score;
              }
              if (streak > (currentProfile.streak || 0)) {
                currentProfile.streak = streak;
              }
              currentProfile.playCount = (currentProfile.playCount || 0) + 1;
              
              if (achievements && achievements.length > 0) {
                if (!currentProfile.achievements) {
                  currentProfile.achievements = [];
                }
                for (const achId of achievements) {
                  if (!currentProfile.achievements.includes(achId)) {
                    currentProfile.achievements.push(achId);
                  }
                }
              }
              
              saveProfileToLocalStorage(currentProfile);
            }
            
            result = { ok: true, local: true };
          }
        } else {
          responseQueue.push({
            action: 'submitScore',
            success: false,
            error: 'Not authenticated - login required'
          });
          return;
        }
        
        console.log('[Bridge] Score submission result:', result);
        
        const success = result && (
          result.ok !== undefined || 
          result.success === true || 
          result.local === true ||
          (typeof result === 'object' && !result.err && !result.error)
        );
        
        if (success) {
          console.log('[Bridge] Score submitted successfully');
          
          responseQueue.push({
            action: 'submitScore',
            success: true,
            score: score,
            streak: streak,
            profile: currentProfile,
            local: result.local || false
          });
          
          if (chedda && chedda.isAuthenticated()) {
            cachedProfileData = null;
            lastProfileFetch = 0;
            chedda.getProfile().then(profile => {
              if (profile) {
                currentProfile = sanitizeProfileData(profile, true);
                saveProfileToLocalStorage(currentProfile);
              }
            }).catch(console.warn);
          }
        } else {
          const errorMsg = result?.err || result?.error || 'Score submission failed';
          console.error('[Bridge] Score submission failed:', errorMsg);
          responseQueue.push({
            action: 'submitScore',
            success: false,
            error: errorMsg
          });
        }
      } catch (error) {
        console.error('[Bridge] Score submission error:', error);
        responseQueue.push({
          action: 'submitScore',
          success: false,
          error: error.message
        });
      } finally {
        isSubmittingScore = false;
      }
    };

    /**
     * Start a play session for time validation anti-cheat
     * Call this when the game STARTS (before submitting any scores)
     * Returns the session token to be used with score submission
     * 
     * v1.5.3: Fixed API response parsing, works for all users
     */
    window.chedda_start_play_session = async function(gameId) {
      try {
        console.log('[Bridge] Starting play session for game:', gameId || CONFIG.GAME_ID);
        
        const targetGameId = gameId || CONFIG.GAME_ID;
        const playerId = deviceId || getOrCreateDeviceId();
        
        // Use HTTP API for ALL users (authenticated and anonymous)
        if (CONFIG.API_KEY) {
          try {
            console.log('[Bridge] Starting play session via HTTP API...');
            const response = await fetch(`${CONFIG.API_BASE_URL}/play-sessions/start`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-API-Key': CONFIG.API_KEY
              },
              body: JSON.stringify({
                gameId: targetGameId,
                playerId: playerId
              })
            });
            
            if (response.ok) {
              const data = await response.json();
              console.log('[Bridge] Play session API response:', data);
              
              // Handle different response formats
              let token = null;
              if (data.data && data.data.token) {
                // Format: { ok: true, data: { token: "xxx" } }
                token = data.data.token;
              } else if (typeof data.ok === 'string' && data.ok.length > 10) {
                // Format: { ok: "token_string" }
                token = data.ok;
              } else if (data.token) {
                // Format: { token: "xxx" }
                token = data.token;
              }
              
              if (token) {
                playSessionToken = token;
                console.log('[Bridge] Play session started (HTTP):', String(playSessionToken).substring(0, 25) + '...');
                return JSON.stringify({ ok: playSessionToken });
              } else {
                console.warn('[Bridge] Could not extract token from response:', data);
              }
            } else {
              const errorText = await response.text();
              console.warn('[Bridge] HTTP API failed:', response.status, errorText);
            }
          } catch (e) {
            console.warn('[Bridge] HTTP API error:', e.message);
          }
        } else {
          console.warn('[Bridge] No API_KEY configured - play sessions disabled');
        }
        
        // Fallback: generate local token (time validation will NOT be enforced)
        playSessionToken = 'local_' + Date.now() + '_' + Math.random().toString(36).substring(2, 8);
        console.log('[Bridge] Play session fallback (no server validation):', playSessionToken);
        return JSON.stringify({ ok: playSessionToken, fallback: true });
        
      } catch (error) {
        console.error('[Bridge] Play session error:', error);
        playSessionToken = 'error_' + Date.now();
        return JSON.stringify({ ok: playSessionToken, fallback: true });
      }
    };

    /**
     * Get current play session token
     */
    window.chedda_get_play_session_token = function() {
      return playSessionToken;
    };

    /**
     * Clear play session (after score submitted)
     */
    window.chedda_clear_play_session = function() {
      playSessionToken = null;
      console.log('[Bridge] Play session cleared');
    };

    /**
     * End/cancel play session on the server
     * Call when player quits without submitting a score
     */
    window.chedda_end_play_session = async function() {
      try {
        const token = playSessionToken;
        if (!token) {
          console.log('[Bridge] No play session to end');
          return JSON.stringify({ ok: true, message: 'No session active' });
        }

        console.log('[Bridge] Ending play session:', token.substring(0, 20) + '...');

        // Skip server call for local/fallback tokens
        if (token.startsWith('local_') || token.startsWith('error_')) {
          playSessionToken = null;
          console.log('[Bridge] Cleared local play session');
          return JSON.stringify({ ok: true, message: 'Local session cleared' });
        }

        // Try HTTP API first (works for all auth types)
        if (CONFIG.API_KEY) {
          try {
            const response = await fetch(`${CONFIG.API_BASE_URL}/play-sessions/end`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-API-Key': CONFIG.API_KEY
              },
              body: JSON.stringify({ playSessionToken: token })
            });

            if (response.ok) {
              playSessionToken = null;
              console.log('[Bridge] Play session ended via HTTP API');
              return JSON.stringify({ ok: true, message: 'Session ended' });
            } else {
              const errorText = await response.text();
              console.warn('[Bridge] End session HTTP failed:', response.status, errorText);
            }
          } catch (e) {
            console.warn('[Bridge] End session HTTP error:', e.message);
          }
        }

        // Fallback: try session token auth
        if (sdkSessionToken) {
          try {
            const response = await fetch(`${CONFIG.API_BASE_URL}/play-sessions/end`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-Session-Token': sdkSessionToken
              },
              body: JSON.stringify({ playSessionToken: token })
            });

            if (response.ok) {
              playSessionToken = null;
              console.log('[Bridge] Play session ended via session token');
              return JSON.stringify({ ok: true, message: 'Session ended' });
            }
          } catch (e) {
            console.warn('[Bridge] End session (session auth) error:', e.message);
          }
        }

        // Last resort: just clear locally
        playSessionToken = null;
        console.log('[Bridge] Play session cleared locally (server end failed)');
        return JSON.stringify({ ok: true, message: 'Session cleared locally' });

      } catch (error) {
        console.error('[Bridge] End play session error:', error);
        playSessionToken = null;
        return JSON.stringify({ ok: false, error: error.message });
      }
    };

    /**
     * Submit score WITH play session token for time validation
     */
    window.chedda_submit_score_with_session = async function(score, streak, sessionToken) {
      // Store the session token for this submission
      const tokenToUse = sessionToken || playSessionToken;
      console.log('[Bridge] Submitting score with session:', tokenToUse ? tokenToUse.substring(0, 20) + '...' : 'none');
      
      // Use the regular submit function - the SDK should handle the token
      // We pass it through the chedda object if supported
      if (chedda && chedda.submitScoreWithSession) {
        try {
          const result = await chedda.submitScoreWithSession(score, streak, tokenToUse);
          responseQueue.push({
            action: 'submitScore',
            success: !result.err,
            score: score,
            streak: streak,
            error: result.err
          });
          return;
        } catch (e) {
          console.warn('[Bridge] submitScoreWithSession not available, using standard submit');
        }
      }
      
      // Fallback: use standard submit (token may be ignored by older SDK)
      // The Godot HTTP API will handle the token directly
      await window.chedda_submit_score(score, streak);
    };

    window.chedda_get_leaderboard = async function(sortBy = 'score', limit = 100) {
      try {
        console.log('[Bridge] Leaderboard requested:', sortBy, limit);
        
        if (!chedda) {
          responseQueue.push({
            action: 'getLeaderboard',
            success: false,
            error: 'SDK not initialized'
          });
          return;
        }
        
        const leaderboard = await chedda.getLeaderboard(sortBy, limit);
        console.log('[Bridge] Leaderboard received:', leaderboard?.length || 0, 'entries');
        
        responseQueue.push({
          action: 'getLeaderboard',
          success: true,
          entries: leaderboard || []
        });
      } catch (error) {
        console.error('[Bridge] Leaderboard error:', error);
        responseQueue.push({
          action: 'getLeaderboard',
          success: false,
          error: error.message
        });
      }
    };

    window.chedda_get_player_rank = async function(sortBy = 'score') {
      try {
        if (!chedda || !chedda.isAuthenticated()) {
          responseQueue.push({
            action: 'getPlayerRank',
            success: false,
            error: 'Not authenticated'
          });
          return;
        }
        
        console.log('[Bridge] Player rank requested:', sortBy);
        const rank = await chedda.getPlayerRank(sortBy);
        
        responseQueue.push({
          action: 'getPlayerRank',
          success: true,
          rank: rank.rank || 0,
          score: rank.score || 0,
          streak: rank.streak || 0,
          totalPlayers: rank.totalPlayers || 0
        });
      } catch (error) {
        console.error('[Bridge] Rank error:', error);
        responseQueue.push({
          action: 'getPlayerRank',
          success: false,
          error: error.message
        });
      }
    };

    window.chedda_unlock_achievement = async function(achievementId, name, description) {
      try {
        if (authType === 'device' || authType === 'anonymous') {
          console.log('[Bridge] Storing achievement locally:', achievementId);
          if (currentProfile) {
            if (!currentProfile.achievements) currentProfile.achievements = [];
            if (!currentProfile.achievements.find(a => a.id === achievementId)) {
              currentProfile.achievements.push({ id: achievementId, name, description });
              saveProfileToLocalStorage(currentProfile);
            }
          }
          responseQueue.push({
            action: 'unlockAchievement',
            success: true,
            achievementId: achievementId,
            local: true
          });
          return;
        }
        
        if (!chedda || !chedda.isAuthenticated()) {
          responseQueue.push({
            action: 'unlockAchievement',
            success: false,
            error: 'Not authenticated'
          });
          return;
        }
        
        console.log('[Bridge] Unlocking achievement:', achievementId);
        await chedda.unlockAchievement(achievementId, name, description);
        
        responseQueue.push({
          action: 'unlockAchievement',
          success: true,
          achievementId: achievementId
        });
      } catch (error) {
        responseQueue.push({
          action: 'unlockAchievement',
          success: false,
          error: error.message
        });
      }
    };

    /**
     * Change nickname directly (called from Godot)
     * FIXED: Now properly updates anonymous profiles
     */
    window.chedda_change_nickname = async function(newNickname) {
      try {
        if (!newNickname || !newNickname.trim()) {
          responseQueue.push({
            action: 'changeNickname',
            success: false,
            error: 'Nickname required'
          });
          return;
        }
        
        const nickname = newNickname.trim();
        console.log('[Bridge] Changing nickname to:', nickname);
        
        // Store as pending nickname for next anonymous login
        pendingNickname = nickname;
        
        // For anonymous users - update immediately
        if (authType === 'device' || authType === 'anonymous') {
          if (currentProfile) {
            currentProfile.nickname = nickname;
            saveProfileToLocalStorage(currentProfile);
            console.log('[Bridge] Anonymous nickname updated to:', nickname);
          }
          responseQueue.push({
            action: 'changeNickname',
            success: true,
            nickname: nickname
          });
          return;
        }
        
        // For authenticated users
        if (!chedda || !chedda.isAuthenticated()) {
          // Not authenticated yet - store for later
          console.log('[Bridge] Storing pending nickname:', nickname);
          responseQueue.push({
            action: 'changeNickname',
            success: true,
            nickname: nickname,
            pending: true
          });
          return;
        }
        
        await chedda.changeNickname(nickname);
        renamedNickname = nickname; // Track - backend may return stale name
        
        if (currentProfile) {
          currentProfile.nickname = nickname;
          saveProfileToLocalStorage(currentProfile);
        }
        
        responseQueue.push({
          action: 'changeNickname',
          success: true,
          nickname: nickname
        });
        
        console.log('[Bridge] Nickname changed successfully');
      } catch (error) {
        console.error('[Bridge] Nickname change error:', error);
        responseQueue.push({
          action: 'changeNickname',
          success: false,
          error: error.message
        });
      }
    };

    /**
     * Change nickname with prompt
     */
    window.chedda_change_nickname_prompt = async function() {
      try {
        const currentNick = currentProfile?.nickname || 'Player';
        const newNickname = (window._realPrompt || prompt)('Enter your nickname:', currentNick);
        
        if (newNickname && newNickname.trim()) {
          await window.chedda_change_nickname(newNickname.trim());
        } else {
          responseQueue.push({
            action: 'changeNickname',
            success: false,
            cancelled: true
          });
        }
      } catch (error) {
        responseQueue.push({
          action: 'changeNickname',
          success: false,
          error: error.message
        });
      }
    };
    
    // ============================================================
    // NICKNAME AVAILABILITY CHECK
    // ============================================================
    
    let nicknameCheckTimeout = null;
    
    /**
     * Check if a nickname is available
     * Returns: { available: bool, reason: string|null, message: string }
     */
    window.chedda_check_nickname = async function(nickname) {
      if (!nickname || nickname.length < 3) {
        return { available: false, reason: 'length', message: 'Name must be at least 3 characters' };
      }
      if (nickname.length > 12) {
        return { available: false, reason: 'length', message: 'Name must be at most 12 characters' };
      }
      if (!/^[a-zA-Z0-9_]+$/.test(nickname)) {
        return { available: false, reason: 'characters', message: 'Only letters, numbers, and underscores' };
      }
      
      try {
        const response = await fetch(`${CONFIG.API_BASE_URL}/nickname/check?name=${encodeURIComponent(nickname)}`, {
          headers: {
            'X-Game-Id': CONFIG.GAME_ID,
            ...(sdkSessionToken && { 'X-Session-Token': sdkSessionToken })
          }
        });
        
        const data = await response.json();
        if (data.success) {
          return {
            available: data.available,
            reason: data.reason,
            message: data.message
          };
        }
        return { available: true, reason: 'unknown', message: 'Could not verify' };
      } catch (e) {
        console.warn('[Nickname] Check failed:', e);
        return { available: true, reason: 'error', message: 'Could not verify' };
      }
    };
    
    /**
     * Show mobile-friendly name input modal with availability check
     * This replaces prompt() which freezes on mobile browsers
     */
    window.chedda_show_name_modal = function(defaultValue, mode) {
      return new Promise((resolve) => {
        // Remove existing modal if any
        const existing = document.getElementById('chedda-name-modal');
        if (existing) existing.remove();
        
        const isRename = mode === 'rename';
        
        // Create modal HTML
        const modal = document.createElement('div');
        modal.id = 'chedda-name-modal';
        modal.innerHTML = `
          <div class="cnm-backdrop"></div>
          <div class="cnm-container">
            <div class="cnm-title">${isRename ? 'Change Name' : 'Enter Your Name'}</div>
            <input type="text" class="cnm-input" value="${defaultValue || ''}" maxlength="12" placeholder="Your name..." autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
            <div class="cnm-status"></div>
            <div class="cnm-buttons">
              <button class="cnm-btn cnm-cancel">Cancel</button>
              <button class="cnm-btn cnm-confirm" disabled>${isRename ? 'Save' : "Let's Go!"}</button>
            </div>
          </div>
        `;
        
        // Add styles
        const style = document.createElement('style');
        style.textContent = `
          #chedda-name-modal { position: fixed; inset: 0; z-index: 999999; display: flex; align-items: center; justify-content: center; }
          .cnm-backdrop { position: absolute; inset: 0; background: rgba(0,0,0,0.8); }
          .cnm-container { position: relative; background: #1a1a2e; border-radius: 16px; padding: 24px; width: 90%; max-width: 320px; box-shadow: 0 8px 32px rgba(0,0,0,0.5); }
          .cnm-title { color: #f5d742; font-size: 20px; font-weight: bold; text-align: center; margin-bottom: 16px; }
          .cnm-input { width: 100%; padding: 14px; font-size: 18px; border: 2px solid #333; border-radius: 8px; background: #0f0f1a; color: #fff; text-align: center; box-sizing: border-box; }
          .cnm-input:focus { outline: none; border-color: #f5d742; }
          .cnm-input.valid { border-color: #4CAF50; }
          .cnm-input.invalid { border-color: #f44336; }
          .cnm-status { height: 24px; margin: 12px 0; text-align: center; font-size: 14px; }
          .cnm-status.checking { color: #888; }
          .cnm-status.available { color: #4CAF50; }
          .cnm-status.taken { color: #f44336; }
          .cnm-status.error { color: #ff9800; }
          .cnm-buttons { display: flex; gap: 12px; }
          .cnm-btn { flex: 1; padding: 14px; font-size: 16px; font-weight: bold; border: none; border-radius: 8px; cursor: pointer; }
          .cnm-cancel { background: #333; color: #fff; }
          .cnm-confirm { background: #f5d742; color: #1a1a2e; }
          .cnm-confirm:disabled { background: #666; color: #999; cursor: not-allowed; }
        `;
        
        document.head.appendChild(style);
        document.body.appendChild(modal);
        
        const input = modal.querySelector('.cnm-input');
        const status = modal.querySelector('.cnm-status');
        const confirmBtn = modal.querySelector('.cnm-confirm');
        const cancelBtn = modal.querySelector('.cnm-cancel');
        const backdrop = modal.querySelector('.cnm-backdrop');
        
        // Focus input (triggers mobile keyboard)
        setTimeout(() => input.focus(), 100);
        
        // Check availability on input
        const checkAvailability = async () => {
          const name = input.value.trim();
          
          if (name.length < 3) {
            status.textContent = name.length > 0 ? 'Name too short (min 3)' : '';
            status.className = 'cnm-status';
            input.className = 'cnm-input' + (name.length > 0 ? ' invalid' : '');
            confirmBtn.disabled = true;
            return;
          }
          
          if (name.length > 12) {
            status.textContent = 'Name too long (max 12)';
            status.className = 'cnm-status taken';
            input.className = 'cnm-input invalid';
            confirmBtn.disabled = true;
            return;
          }
          
          if (!/^[a-zA-Z0-9_]+$/.test(name)) {
            status.textContent = 'Letters, numbers, _ only';
            status.className = 'cnm-status taken';
            input.className = 'cnm-input invalid';
            confirmBtn.disabled = true;
            return;
          }
          
          // Same as current name? Always allow
          const currentNick = currentProfile?.nickname || '';
          if (name.toLowerCase() === currentNick.toLowerCase()) {
            status.textContent = '✓ Current name';
            status.className = 'cnm-status available';
            input.className = 'cnm-input valid';
            confirmBtn.disabled = false;
            return;
          }
          
          status.textContent = 'Checking...';
          status.className = 'cnm-status checking';
          
          const result = await window.chedda_check_nickname(name);
          
          // Check if input changed while checking
          if (input.value.trim() !== name) return;
          
          if (result.available) {
            status.textContent = '✓ ' + (result.message || 'Available!');
            status.className = 'cnm-status available';
            input.className = 'cnm-input valid';
            confirmBtn.disabled = false;
          } else {
            status.textContent = '✗ ' + (result.message || 'Not available');
            status.className = 'cnm-status taken';
            input.className = 'cnm-input invalid';
            confirmBtn.disabled = true;
          }
        };
        
        // Debounced check on input
        input.addEventListener('input', () => {
          clearTimeout(nicknameCheckTimeout);
          nicknameCheckTimeout = setTimeout(checkAvailability, 300);
        });
        
        // Initial check if there's a default value
        if (defaultValue) {
          setTimeout(checkAvailability, 100);
        }
        
        // Cleanup function
        const cleanup = () => {
          modal.remove();
          style.remove();
        };
        
        // Confirm
        confirmBtn.addEventListener('click', () => {
          const name = input.value.trim();
          cleanup();
          resolve(name || null);
        });
        
        // Cancel
        cancelBtn.addEventListener('click', () => {
          cleanup();
          resolve(null);
        });
        
        // Backdrop click = cancel
        backdrop.addEventListener('click', () => {
          cleanup();
          resolve(null);
        });
        
        // Enter key = confirm (if enabled)
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !confirmBtn.disabled) {
            confirmBtn.click();
          }
        });
      });
    };
    
    // ============================================================
    // INITIALIZATION
    // ============================================================
    window.addEventListener('load', async () => {
      console.log('[Init] CheddaBoards Template v1.5.15 (Fixed _realPrompt for mobile)');
      console.log('[Init] Game ID:', CONFIG.GAME_ID);
      console.log('[Init] Anonymous Play:', CONFIG.ALLOW_ANONYMOUS_PLAY ? 'Enabled' : 'Disabled');

      getOrCreateDeviceId();

      if (CONFIG.GAME_ID === 'YOUR-GAME-ID') {
        console.error('[Init] ERROR: You must set your GAME_ID in the CONFIG section!');
        document.querySelector('.loading-text').textContent = 'Error: Game not configured';
        return;
      }

      try {
        let attempts = 0;
        while (!window.CheddaBoards && attempts < 50) {
          await new Promise(resolve => setTimeout(resolve, 100));
          attempts++;
        }

        if (!window.CheddaBoards) {
          throw new Error('CheddaBoards SDK not loaded. Check your internet connection.');
        }

        console.log('[Init] Initializing CheddaBoards...');
        chedda = await window.CheddaBoards.init(CONFIG.CANISTER_ID, {
          gameId: CONFIG.GAME_ID,
          host: 'https://icp-api.io'
        });

        window.chedda = chedda;
        console.log('[Init] CheddaBoards initialized');

        if (chedda.isAuthenticated()) {
          console.log('[Init] User is authenticated');
          isAuthenticated = true;
          authType = chedda.getAuthType ? chedda.getAuthType() : 'unknown';
          
          // Capture session token - check chedda.instance first (wrapper pattern)
          sdkSessionToken = null;
          if (chedda.instance?.sessionId) {
            sdkSessionToken = chedda.instance.sessionId;
          } else if (chedda.instance?.userId) {
            sdkSessionToken = chedda.instance.userId;
          } else if (typeof chedda.getSessionId === 'function') {
            sdkSessionToken = chedda.getSessionId();
          } else if (chedda.sessionId) {
            sdkSessionToken = chedda.sessionId;
          }
          console.log('[Init] Session token restored:', sdkSessionToken ? sdkSessionToken.substring(0, 20) + '...' : 'none');

          const cachedProfile = loadProfileFromLocalStorage();
          if (cachedProfile) {
            currentProfile = cachedProfile;
            responseQueue.push({
              action: 'init',
              success: true,
              authenticated: true,
              authType,
              profile: currentProfile,
              sessionToken: sdkSessionToken || null
            });
          } else {
            responseQueue.push({
              action: 'init',
              success: true,
              authenticated: true,
              authType,
              profile: null,
              sessionToken: sdkSessionToken || null
            });
          }

          chedda.getProfile().then(profile => {
            if (profile) {
              currentProfile = sanitizeProfileData(profile);
              saveProfileToLocalStorage(currentProfile);
              responseQueue.push({
                action: 'getProfile',
                success: true,
                profile: currentProfile,
                sessionToken: sdkSessionToken || null
              });
            }
          }).catch(console.error);
        } else if (CONFIG.ALLOW_ANONYMOUS_PLAY) {
          console.log('[Init] Setting up anonymous play with device ID');
          const cachedProfile = loadProfileFromLocalStorage();
          if (cachedProfile && cachedProfile.deviceId === deviceId) {
            currentProfile = cachedProfile;
            authType = 'device';
            console.log('[Init] Restored anonymous profile:', currentProfile.nickname);
          }
          
          responseQueue.push({
            action: 'init',
            success: true,
            authenticated: false,
            anonymousReady: true,
            deviceId: deviceId,
            cachedNickname: currentProfile?.nickname || null
          });
        } else {
          responseQueue.push({
            action: 'init',
            success: true,
            authenticated: false
          });
        }

        // Initialize Google Sign-In
        if (CONFIG.GOOGLE_CLIENT_ID && window.google?.accounts) {
          google.accounts.id.initialize({
            client_id: CONFIG.GOOGLE_CLIENT_ID,
            callback: async (response) => {
              if (window._googleLoginTimeout) {
                clearTimeout(window._googleLoginTimeout);
              }
              if (window._googleUpgradeTimeout) {
                clearTimeout(window._googleUpgradeTimeout);
              }
              
              try {
                // Check if this is an upgrade flow
                if (window._isUpgradeFlow === 'google' && window._upgradeDeviceId) {
                  const capturedDeviceId = window._upgradeDeviceId;
                  window._isUpgradeFlow = null;
                  window._upgradeDeviceId = null;

                  console.log('[Upgrade] Google credential received, upgrading...');

                  // Capture anonymous nickname BEFORE login overwrites currentProfile
                  const previousNickname = (currentProfile && currentProfile.nickname) 
                    ? currentProfile.nickname 
                    : pendingNickname;
                  console.log('[Upgrade] Preserving anonymous nickname:', previousNickname);

                  // Login first (pass nickname to suppress SDK's new-user prompt)
                  const profile = await chedda.login.google(response.credential, previousNickname || 'Player');
                  handleLoginSuccess('google', profile);
                  const migration = await _migrateViaHttp(capturedDeviceId);

                  // Refresh profile to get the REAL account data after migration
                  let refreshedProfile = null;
                  if (migration.success && chedda.refreshProfile) {
                    try {
                      const fresh = await chedda.refreshProfile();
                      if (fresh) {
                        refreshedProfile = sanitizeProfileData(fresh, true);
                        currentProfile = refreshedProfile;
                        saveProfileToLocalStorage(currentProfile);
                      }
                    } catch (e) {
                      console.warn('[Upgrade] Profile refresh failed:', e);
                    }
                  }

                  // Only carry the anonymous nickname over if the target account
                  // was genuinely new (all plays came from migration, no pre-existing data).
                  // If the account already existed with its own nickname/scores, keep it.
                  const migratedGames = (migration && migration.migratedGames) || 0;
                  const accountPlayCount = refreshedProfile ? (refreshedProfile.playCount || 0) : 0;
                  const accountIsNew = accountPlayCount <= migratedGames;

                  if (accountIsNew && previousNickname && chedda.changeNickname) {
                    try {
                      console.log('[Upgrade] New account - restoring anonymous nickname:', previousNickname);
                      await chedda.changeNickname(previousNickname);
                      if (currentProfile) {
                        currentProfile.nickname = previousNickname;
                        saveProfileToLocalStorage(currentProfile);
                      }
                      console.log('[Upgrade] Nickname restored successfully');
                    } catch (e) {
                      console.warn('[Upgrade] Nickname restore failed:', e);
                    }
                  } else {
                    console.log('[Upgrade] Existing account (plays: ' + accountPlayCount + ', migrated: ' + migratedGames + ') - keeping nickname: ' + (currentProfile ? currentProfile.nickname : 'unknown'));
                  }

                  responseQueue.push({
                    action: 'upgradeToGoogle',
                    success: true,
                    profile: currentProfile,
                    migration: migration
                  });
                } else {
                  // Normal login flow (pass nickname to suppress SDK's new-user prompt)
                  const existingNick = currentProfile?.nickname || localStorage.getItem('chedda_nickname') || 'Player';
                  const profile = await chedda.login.google(response.credential, existingNick);
                  handleLoginSuccess('google', profile);
                }
              } catch (error) {
                window._isUpgradeFlow = null;
                window._upgradeDeviceId = null;
                handleLoginError(error);
              }
            },
            auto_select: false,
            cancel_on_tap_outside: true
          });
          
          console.log('[Init] Google Sign-In initialized');
        }

        // Initialize Apple Sign-In
        if (CONFIG.APPLE_SERVICE_ID && CONFIG.APPLE_REDIRECT_URI && window.AppleID?.auth) {
          AppleID.auth.init({
            clientId: CONFIG.APPLE_SERVICE_ID,
            scope: 'name email',
            redirectURI: CONFIG.APPLE_REDIRECT_URI,
            state: 'signin',
            usePopup: true
          });

          document.addEventListener('AppleIDSignInOnSuccess', async (event) => {
            if (window._appleLoginTimeout) {
              clearTimeout(window._appleLoginTimeout);
            }
            if (window._appleUpgradeTimeout) {
              clearTimeout(window._appleUpgradeTimeout);
            }

            try {
              const auth = event.detail?.authorization;
              if (!auth?.id_token) throw new Error("Missing id_token");

              // Check if this is an upgrade flow
              if (window._isUpgradeFlow === 'apple' && window._upgradeDeviceId) {
                const capturedDeviceId = window._upgradeDeviceId;
                window._isUpgradeFlow = null;
                window._upgradeDeviceId = null;

                console.log('[Upgrade] Apple credential received, upgrading...');

                // Capture anonymous nickname BEFORE login overwrites currentProfile
                const previousAppleNickname = (currentProfile && currentProfile.nickname) 
                  ? currentProfile.nickname 
                  : pendingNickname;
                console.log('[Upgrade] Preserving anonymous nickname:', previousAppleNickname);

                // Login first (pass nickname to suppress SDK's new-user prompt)
                const profile = await chedda.login.apple(auth, previousAppleNickname || 'Player');
                handleLoginSuccess('apple', profile);

                // Then migrate
                const migration = await _migrateViaHttp(capturedDeviceId);

                // Refresh profile to get the REAL account data after migration
                let refreshedAppleProfile = null;
                if (migration.success && chedda.refreshProfile) {
                  try {
                    const fresh = await chedda.refreshProfile();
                    if (fresh) {
                      refreshedAppleProfile = sanitizeProfileData(fresh, true);
                      currentProfile = refreshedAppleProfile;
                      saveProfileToLocalStorage(currentProfile);
                    }
                  } catch (e) {
                    console.warn('[Upgrade] Profile refresh failed:', e);
                  }
                }

                // Only carry anonymous nickname if target account was genuinely new
                const appleMigratedGames = (migration && migration.migratedGames) || 0;
                const applePlayCount = refreshedAppleProfile ? (refreshedAppleProfile.playCount || 0) : 0;
                const appleAccountIsNew = applePlayCount <= appleMigratedGames;

                if (appleAccountIsNew && previousAppleNickname && chedda.changeNickname) {
                  try {
                    console.log('[Upgrade] New account - restoring anonymous nickname:', previousAppleNickname);
                    await chedda.changeNickname(previousAppleNickname);
                    if (currentProfile) {
                      currentProfile.nickname = previousAppleNickname;
                      saveProfileToLocalStorage(currentProfile);
                    }
                  } catch (e) {
                    console.warn('[Upgrade] Nickname restore failed:', e);
                  }
                } else {
                  console.log('[Upgrade] Existing account (plays: ' + applePlayCount + ', migrated: ' + appleMigratedGames + ') - keeping nickname');
                }

                responseQueue.push({
                  action: 'upgradeToApple',
                  success: true,
                  profile: currentProfile,
                  migration: migration
                });
              } else {
                // Normal login flow (pass nickname to suppress SDK's new-user prompt)
                const existingAppleNick = currentProfile?.nickname || localStorage.getItem('chedda_nickname') || 'Player';
                const profile = await chedda.login.apple(auth, existingAppleNick);
                handleLoginSuccess('apple', profile);
              }
            } catch (error) {
              window._isUpgradeFlow = null;
              window._upgradeDeviceId = null;
              handleLoginError(error);
            }
          });

          document.addEventListener('AppleIDSignInOnFailure', (event) => {
            if (window._appleLoginTimeout) {
              clearTimeout(window._appleLoginTimeout);
            }
            if (window._appleUpgradeTimeout) {
              clearTimeout(window._appleUpgradeTimeout);
            }
            window._isUpgradeFlow = null;
            window._upgradeDeviceId = null;
            handleLoginError({ message: 'Apple Sign-In failed or cancelled' });
          });

          console.log('[Init] Apple Sign-In initialized');
        }

        // Initialize Godot engine
        const engine = new Engine({
          canvasResizePolicy: 2,
          executable: 'index',
          fileSizes: { 'index.pck': 0, 'index.wasm': 0 },
          focusCanvas: true,
          canvas: document.getElementById('canvas')
        });

        await engine.startGame();
        window.godot = engine;
        godotReady = true;
        console.log('[Init] Godot engine started');

        setTimeout(() => {
          const preload = document.getElementById('preload');
          preload?.classList.add('fade');
          setTimeout(() => preload?.remove(), 500);
        }, 500);

        console.log('[Init] All systems ready!');
        
      } catch (error) {
        console.error('[Init] Initialization failed:', error);
        document.querySelector('.loading-text').textContent = 'Error: ' + error.message;
      }
    });

    // ============================================================
    // DEBUG HELPER
    // ============================================================
    window.debugChedda = () => {
      console.log('═══════════════════════════════════════');
      console.log('CheddaBoards Debug Info v1.6.0');
      console.log('═══════════════════════════════════════');
      console.log('Game ID:', CONFIG.GAME_ID);
      console.log('Anonymous Play:', CONFIG.ALLOW_ANONYMOUS_PLAY);
      console.log('───────────────────────────────────────');
      console.log('SDK Instance:', chedda ? 'Loaded' : 'Not loaded');
      console.log('SDK Authenticated:', chedda?.isAuthenticated() || false);
      console.log('Local Authenticated:', isAuthenticated);
      console.log('Auth Type:', authType || 'None');
      console.log('Device ID:', deviceId ? deviceId.substring(0, 12) + '...' : 'Not set');
      console.log('───────────────────────────────────────');
      console.log('Session Token (cached):', sdkSessionToken ? sdkSessionToken.substring(0, 20) + '...' : 'Not set');
      console.log('SDK .instance.sessionId:', chedda?.instance?.sessionId ? chedda.instance.sessionId.substring(0, 20) + '...' : 'None');
      console.log('SDK .instance.userId:', chedda?.instance?.userId ? chedda.instance.userId.substring(0, 20) + '...' : 'None');
      console.log('SDK .instance.authType:', chedda?.instance?.authType || 'None');
      console.log('Pending Nickname:', pendingNickname || 'None');
      console.log('Renamed Nickname Override:', renamedNickname || 'None');
      console.log('───────────────────────────────────────');
      console.log('Play Session:', playSessionToken ? playSessionToken.substring(0, 20) + '...' : 'None');
      console.log('Upgrade Flow Active:', window._isUpgradeFlow || 'None');
      console.log('───────────────────────────────────────');
      console.log('Profile:', currentProfile);
      console.log('Response Queue:', responseQueue.length, 'items');
      console.log('Godot Ready:', godotReady);
      console.log('───────────────────────────────────────');
      console.log('Google:', CONFIG.GOOGLE_CLIENT_ID ? 'Configured' : 'Disabled');
      console.log('Apple:', CONFIG.APPLE_SERVICE_ID ? 'Configured' : 'Disabled');
      console.log('═══════════════════════════════════════');
      
      return { chedda, currentProfile, responseQueue, deviceId, pendingNickname, renamedNickname, playSessionToken, sdkSessionToken, CONFIG };
    };
  </script>
</body>
</html>
